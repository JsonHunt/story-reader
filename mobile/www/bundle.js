(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var app, modules;

  this.isPhoneGap = document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;

  modules = ['ngRoute', 'ngTouch', 'monospaced.elastic'];

  if (this.isPhoneGap) {
    modules.push('ngCordova');
  }

  app = angular.module('PublicApp', modules);

  app.controller('IndexController', require('./index-controller'));

  app.directive('tap', require('./directives').tap);

  app.directive('ngEnter', require('./directives').enter);

  app.config([
    '$httpProvider', '$routeProvider', function($httpProvider, $routeProvider) {
      return $routeProvider.when('/', {
        controller: require('./home/home'),
        templateUrl: 'home/home.html'
      }).when('/story/:id/:opt?/:rec?', {
        controller: require('./story/story'),
        templateUrl: 'story/story.html'
      }).when('/edit/:id', {
        controller: require('./edit/edit'),
        templateUrl: 'edit/edit.html'
      }).when('/record', {
        controller: require('./recording/recording'),
        templateUrl: 'recording/recording.html'
      }).otherwise({
        redirectTo: '/'
      });
    }
  ]);

  if (this.isPhoneGap) {
    console.log("PHONEGAP APPLICATION");
    document.addEventListener('deviceready', function() {
      return angular.bootstrap(document, ['PublicApp']);
    }, false);
  } else {
    console.log("BROWSER");
    angular.bootstrap(document, ['PublicApp']);
  }

  module.exports = app;

}).call(this);

},{"./directives":2,"./edit/edit":3,"./home/home":6,"./index-controller":7,"./recording/recording":9,"./story/story":12}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  exports.tap = function($timeout) {
    return {
      restrict: 'A',
      link: function(scope, elem, attr) {
        return elem.on('touchend', function(event) {
          var cooldown, _ref, _ref1;
          if (cooldown) {
            return;
          }
          cooldown = true;
          if (this.isPhoneGap && ((_ref = window.plugins) != null ? (_ref1 = _ref.deviceFeedback) != null ? _ref1.acoustic : void 0 : void 0)) {
            window.plugins.deviceFeedback.acoustic();
          }
          $timeout(function() {
            return scope.$apply(function() {
              elem.removeClass('tapped');
              return cooldown = false;
            });
          }, 100);
          return scope.$apply(function() {
            elem.addClass('tapped');
            return scope.$eval(attr.tap);
          });
        });
      }
    };
  };

  exports.enter = function() {
    return function(scope, element, attrs) {
      return element.bind("keyup", function(event) {
        if (event.which === 13) {
          scope.$apply(function() {
            return scope.$eval(attrs.ngEnter);
          });
          return event.preventDefault();
        }
      });
    };
  };

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var EditController, storyParser;

  storyParser = require('./story-parser');

  module.exports = EditController = function($scope, $location, $routeParams, $timeout) {
    var id, lastID;
    $('input.title').hide();
    $('.story').hide();
    setTimeout(function() {
      $('input.title').show();
      return $('.story').show();
    }, 50);
    id = parseInt($routeParams.id);
    if (id !== 0) {
      $scope.story = _.find($scope.stories, function(s) {
        return parseInt(s.id) === id;
      });
      if (!$scope.story) {
        goto('home');
        return;
      }
    } else {
      lastID = window.localStorage.getItem('lastID');
      if (lastID == null) {
        lastID = 0;
      }
      $scope.story = {
        id: parseInt(lastID) + 1
      };
    }
    console.log("STORY ID: " + $scope.story.id);
    $scope.titleEnter = function() {
      return $('.story').focus();
    };
    $scope.textEnter = function() {
      return $('.story').blur();
    };
    $scope.save = function() {
      var result, s, text, title, titlearr, w, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      title = $scope.story.title;
      if (!title || title.length === 0) {
        $scope.error = "Title is required";
        return;
      } else {
        titlearr = title.split(' ');
        title = '';
        for (_i = 0, _len = titlearr.length; _i < _len; _i++) {
          w = titlearr[_i];
          title += S(w).capitalize().s + " ";
        }
        $scope.story.id = parseInt($scope.story.id);
        $scope.story.title = S(title).trim().s;
      }
      text = $scope.story.text;
      if (!text || text.length === 0) {
        $scope.error = "Story is too short!";
        return;
      }
      result = storyParser.parse($scope.story.text);
      $scope.story.sentences = result.sentences;
      text = '';
      _ref = result.sentences;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        s = _ref[_j];
        _ref1 = s.words;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          w = _ref1[_k];
          text += w + ' ';
        }
      }
      $scope.story.text = text;
      if (id === 0) {
        $scope.stories.push($scope.story);
      }
      $scope.allWords = _.union($scope.allWords, result.words);
      window.localStorage.setItem('stories', JSON.stringify($scope.stories));
      window.localStorage.setItem('words', JSON.stringify($scope.allWords));
      window.localStorage.setItem('lastID', $scope.story.id);
      return $location.path("story/" + $scope.story.id + "/1/1");
    };
    $scope["delete"] = function() {
      var i, s, _i, _len, _ref;
      id = parseInt($routeParams.id);
      if (id === 0) {
        $scope.goto('home');
        return;
      }
      _ref = $scope.stories;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        s = _ref[i];
        if (s.id === $scope.story.id) {
          $scope.stories.splice(i, 1);
          window.localStorage.setItem('stories', JSON.stringify($scope.stories));
          break;
        }
      }
      return $timeout(function() {
        return $scope.goto('home');
      }, 100);
    };
    $scope.searchForStoryImage = function() {
      return $scope.imageSearch = true;
    };
    return $scope.captureStoryImage = function() {};
  };

  EditController.$inject = ['$scope', '$location', '$routeParams', '$timeout'];

}).call(this);

},{"./story-parser":4}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var S, StoryParser, _;

  S = require("string");

  _ = require("underscore");

  StoryParser = (function() {
    function StoryParser() {}

    StoryParser.prototype.parse = function(text) {
      var message, p, punctuation, result, sentenceReg, storyReg, word, words, _i, _len;
      result = {
        words: [],
        sentences: []
      };
      if (!S(text).endsWith('.') || !S(text).endsWith('!') || !S(text).endsWith('?') || !S(text).endsWith('...')) {
        text += '.';
      }
      storyReg = /[\s\S]*?[\.\!\?](\.\.)?/gm;
      punctuation = ['(', ')', ',', '...', '!', '?', ';', '.', ':', '"'];
      for (_i = 0, _len = punctuation.length; _i < _len; _i++) {
        p = punctuation[_i];
        text = S(text).replaceAll(p, " " + p + " ");
      }
      while (message = storyReg.exec(text)) {
        sentenceReg = /\S+/gm;
        words = [];
        while (word = sentenceReg.exec(message[0])) {
          if (words.length === 0) {
            word[0] = S(word[0]).capitalize().s;
          }
          words.push(word[0]);
          if (!_.contains(result.words, word[0].toLowerCase()) && !_.contains(punctuation, word[0])) {
            result.words.push(word[0].toLowerCase());
          }
        }
        if (words.length === 0) {
          continue;
        }
        if (words.length === 1 && _.contains(punctuation, words[0])) {
          continue;
        }
        result.sentences.push({
          words: words
        });
      }
      return result;
    };

    return StoryParser;

  })();

  module.exports = new StoryParser();

}).call(this);

},{"string":14,"underscore":15}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var FileService,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  FileService = (function() {
    function FileService() {
      this.initialize = __bind(this.initialize, this);
    }

    FileService.prototype.initialize = function(callback) {
      if (cordova === void 0) {
        return;
      }
      return window.resolveLocalFileSystemURL(cordova.file.externalDataDirectory, (function(_this) {
        return function(fileEntry) {
          _this.root = fileEntry.toURL();
          if (callback) {
            return callback();
          }
        };
      })(this));
    };

    FileService.prototype.getURL = function(filename) {
      if (!root) {
        return console.log("File service was not initialized");
      } else {
        return this.root + "/" + filename;
      }
    };

    return FileService;

  })();

  module.exports = new FileService();

}).call(this);

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var service, storage;

  service = require('./../story-service');

  storage = require('./../storage-service');

  module.exports = [
    '$scope', function($scope) {
      $scope.allCaps = storage.loadInt('allCaps');
      $scope.stories = service.getStories();
      $scope.select = function(s) {
        return $scope.goto("story/" + s.id);
      };
      $scope.remove = function(s) {
        return service.removeStory(s);
      };
      $scope.newStory = function() {
        return $scope.select(service.newStory("New Story"));
      };
      return $scope.toggleCaps = function() {
        $scope.capOn = !$scope.capOn;
        return storage.saveInt('allCaps');
      };
    }
  ];

}).call(this);

},{"./../storage-service":10,"./../story-service":11}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var IndexController, fileService;

  fileService = require('./file-service');

  module.exports = IndexController = function($scope, $location, $cordovaFile) {
    var wordsString;
    fileService.initialize();
    $scope.appTitle = "Story Reader";
    $scope.punctuation = ['(', ')', ',', '...', '!', '?', ';', '.', ':', '"'];
    $scope.log = function(toLog) {
      return console.log(JSON.stringify(toLog, null, 2));
    };
    wordsString = window.localStorage.getItem("words");
    if (wordsString == null) {
      wordsString = JSON.stringify([]);
    }
    $scope.allWords = JSON.parse(wordsString);
    window.addEventListener('native.keyboardshow', function(e) {
      return $scope.$apply(function() {
        return $scope.keyboard = true;
      });
    });
    window.addEventListener('native.keyboardhide', function(e) {
      return $scope.$apply(function() {
        return $scope.keyboard = false;
      });
    });
    $scope.goto = function(path) {
      return $location.path(path);
    };
    return $scope.back = function() {
      return window.history.back();
    };
  };

  if (this.isPhoneGap) {
    IndexController.$inject = ['$scope', '$location', '$cordovaFile'];
  } else {
    IndexController.$inject = ['$scope', '$location'];
  }

}).call(this);

},{"./file-service":5}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var MediaService, fileService,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fileService = require('./file-service');

  MediaService = (function() {
    function MediaService() {
      this.record = __bind(this.record, this);
      this.play = __bind(this.play, this);
    }

    MediaService.prototype.getURL = function(path) {
      return fileService.getURL(path);
    };

    MediaService.prototype.play = function(path, callback) {
      var done, url;
      url = fileService.getURL(path);
      done = (function(_this) {
        return function() {
          _this.stop();
          return callback();
        };
      })(this);
      this.media = new Media(url, done, done);
      this.media.play();
      return this.playing = path;
    };

    MediaService.prototype.record = function(path) {
      var done, url;
      url = fileService.getURL(path);
      done = (function(_this) {
        return function() {
          _this.stop();
          return callback();
        };
      })(this);
      this.media = new Media(url, done, done);
      this.media.startRecord();
      return this.recording = path;
    };

    MediaService.prototype.stop = function() {
      if (this.listening) {
        this.recognition.stop();
        delete this.listening;
      }
      if (this.media) {
        if (this.playing) {
          this.media.stop();
          delete this.playing;
        }
        if (this.recording) {
          this.media.stopRecord();
          delete this.recording;
        }
        this.media.release();
        return delete this.media;
      }
    };

    MediaService.prototype.listen = function(continuous, callback) {
      var e;
      try {
        this.stop();
        this.recognition = new SpeechRecognition();
        this.recognition.continuous = true;
        this.listening = true;
        this.lastResult = "";
        this.recognition.onresult = (function(_this) {
          return function(event) {
            var newResult, result;
            result = event.results[0][0].transcript;
            console.log("Result: " + result);
            newResult = result.substr(_this.lastResult.length);
            _this.lastResult = result;
            return callback(newResult);
          };
        })(this);
        this.recognition.onend = function(event) {
          return console.log("ended");
        };
        this.recognition.onnomatch = function(event) {
          return console.log("no match");
        };
        return this.recognition.start();
      } catch (_error) {
        e = _error;
        return console.log(e);
      }
    };

    return MediaService;

  })();

  module.exports = new MediaService();

}).call(this);

},{"./file-service":5}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var RecordingController;

  module.exports = RecordingController = function($scope, $location, $timeout) {
    $scope.play = function(word) {
      var filename;
      filename = $scope.folderPath + ("/" + word + ".mp3");
      console.log("Playing: " + filename);
      $scope.media = new Media(filename, function(success) {
        return $scope.$apply(function() {
          return $scope.playing = void 0;
        });
      }, function(error) {
        console.log(JSON.stringify(error));
        return $scope.$apply(function() {
          return $scope.playing = void 0;
        });
      }, function(status) {
        return console.log(JSON.stringify(status));
      });
      return $scope.media.play();
    };
    $scope.record = function(word) {
      var filename;
      filename = $scope.folderPath + ("/" + word + ".mp3");
      $scope.stop();
      console.log("Recording: " + filename);
      $scope.recording = word;
      $scope.media = new Media(filename, function(success) {
        return $scope.$apply(function() {
          return $scope.recording = void 0;
        });
      }, function(error) {
        console.log(JSON.stringify(error));
        return $scope.$apply(function() {
          return $scope.recording = void 0;
        });
      }, function(status) {
        return console.log(JSON.stringify(status));
      });
      return $scope.media.startRecord();
    };
    $scope["continue"] = function() {
      $scope.stop();
      return $scope.goto('home');
    };
    return $scope.stop = function() {
      if ($scope.playing) {
        if ($scope.media) {
          $scope.media.stop();
          $scope.playing = void 0;
        }
      }
      if ($scope.recording) {
        if ($scope.media) {
          $scope.media.stopRecord();
          return $scope.recording = void 0;
        }
      }
    };
  };

  RecordingController.$inject = ['$scope', '$location', '$timeout'];

}).call(this);

},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var StorageService;

  StorageService = (function() {
    function StorageService() {}

    StorageService.prototype.resetID = function() {
      return saveInt('nextID', 0);
    };

    StorageService.prototype.getNextID = function() {
      var nextID;
      nextID = this.loadInt('nextID');
      this.saveInt('nextID', nextID + 1);
      return nextID;
    };

    StorageService.prototype.save = function(key, value) {
      return window.localStorage.setItem(key, JSON.stringify(value));
    };

    StorageService.prototype.saveInt = function(key, value) {
      return window.localStorage.setItem(key, value);
    };

    StorageService.prototype.remove = function(key) {
      return window.localStorage.removeItem(key);
    };

    StorageService.prototype.load = function(key) {
      var value;
      value = window.localStorage.getItem(key);
      if (value === null) {
        return {};
      }
      return JSON.parse(value);
    };

    StorageService.prototype.loadArray = function(key) {
      var value;
      value = window.localStorage.getItem(key);
      if (value === null) {
        return [];
      }
      return JSON.parse(value);
    };

    StorageService.prototype.loadInt = function(key) {
      var value;
      value = window.localStorage.getItem(key);
      if (value === null) {
        return 0;
      }
      return parseInt(value);
    };

    return StorageService;

  })();

  module.exports = new StorageService();

}).call(this);

},{}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var S, StoryService, storage,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  storage = require('./storage-service');

  S = require('string');

  StoryService = (function() {
    StoryService.prototype.punctuation = ['(', ')', ',', '...', '!', '?', ';', '.', ':', '"'];

    function StoryService() {
      this.savePage = __bind(this.savePage, this);
      this.removePage = __bind(this.removePage, this);
      this.addPage = __bind(this.addPage, this);
      this.getPages = __bind(this.getPages, this);
      this.selectStory = __bind(this.selectStory, this);
      this.removeStory = __bind(this.removeStory, this);
      this.newStory = __bind(this.newStory, this);
      this.resetStories = __bind(this.resetStories, this);
      this.getStories = __bind(this.getStories, this);
      this.stories = storage.loadArray('stories');
    }

    StoryService.prototype.getStories = function() {
      return this.stories;
    };

    StoryService.prototype.resetStories = function() {
      this.stories = [];
      return storage.save(this.stories);
    };

    StoryService.prototype.newStory = function(title, imageURL) {
      var story;
      story = {
        id: storage.getNextID(),
        title: title,
        imageURL: imageURL
      };
      this.stories.push(story);
      storage.save('stories', this.stories);
      this.selectStory(story.id);
      this.addPage(title, imageURL);
      return story;
    };

    StoryService.prototype.removeStory = function(story) {
      _.remove(this.stories, function(s) {
        return s.id === story.id;
      });
      return storage.save('stories', this.stories);
    };

    StoryService.prototype.selectStory = function(storyID) {
      this.pagesKey = "story-pages-" + storyID;
      this.pages = storage.loadArray(this.pagesKey);
      return this.story = _.find(this.stories, function(s) {
        return s.id === storyID;
      });
    };

    StoryService.prototype.getPages = function() {
      return this.pages;
    };

    StoryService.prototype.addPage = function(text, imageURL) {
      var page;
      if (this.story === void 0) {
        console.log("Cannot add page. Story not selected");
        return;
      }
      page = {
        id: storage.getNextID(),
        text: text,
        imageURL: imageURL
      };
      this.pages.push(page);
      return this.savePage(page);
    };

    StoryService.prototype.removePage = function(pageID) {
      if (pageID === this.pages[0].id) {
        return;
      }
      _.remove(this.pages, function(p) {
        return p.id === pageID;
      });
      return storage.save(this.pagesKey, this.pages);
    };

    StoryService.prototype.savePage = function(page) {
      var p, text, _i, _len, _ref;
      _ref = this.punctuation;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        text = S(page.text).replaceAll(p, " " + p + " ").s;
      }
      page.text = S(text).collapseWhitespace().s;
      page.words = text.split(" ");
      storage.save(this.pagesKey, this.pages);
      if (this.pages[0].id === page.id) {
        this.story.title = page.text;
        this.story.imageURL = page.imageURL;
        return storage.save('stories', this.stories);
      }
    };

    return StoryService;

  })();

  module.exports = new StoryService();

}).call(this);

},{"./storage-service":10,"string":14}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.9.0
(function() {
  var StoryController, mediaService, services, storyService;

  storyService = require('./../story-service');

  mediaService = require('./../media-service');

  module.exports = StoryController = function($scope, $location, $routeParams, $timeout, $http, $cordovaFile, $cordovaFileTransfer, $cordovaCamera) {
    console.log("Story ID: " + $routeParams.id);
    storyService.selectStory(parseInt($routeParams.id));
    $scope.pages = storyService.getPages();
    $scope.pageIndex = 0;
    $scope.page = $scope.pages[0];
    $scope.mode = 'read';
    $scope.isStart = function() {
      return $scope.pageIndex === 0;
    };
    $scope.isEnd = function() {
      return $scope.pageIndex + 1 >= $scope.pages.length;
    };
    $scope.stopMedia = function() {
      return mediaService.stop();
    };
    $scope.nextPage = function() {
      mediaService.stop();
      if (!this.isEnd()) {
        $scope.pageIndex++;
        return $scope.page = $scope.pages[$scope.pageIndex];
      }
    };
    $scope.prevPage = function() {
      mediaService.stop();
      if (!this.isStart()) {
        $scope.pageIndex--;
        return $scope.page = $scope.pages[$scope.pageIndex];
      }
    };
    $scope.home = function() {
      return $scope.goto('');
    };
    $scope.toggleOptions = function() {
      mediaService.stop();
      return $scope.options = !$scope.options;
    };
    $scope.toggleEditPageText = function() {
      $scope.textEdit = !$scope.textEdit;
      if ($scope.textEdit) {
        return setTimeout(function() {
          return $('#pagetext').focus();
        }, 50);
      }
    };
    $scope.toggleEditMode = function() {
      if ($scope.mode === 'edit') {
        return $scope.mode = 'read';
      } else {
        return $scope.mode = 'edit';
      }
    };
    $scope.deletePage = function() {
      if ($scope.pages.length === 1) {
        return;
      }
      storyService.removePage($scope.page.id);
      $scope.confirmDeletePage = false;
      if ($scope.pageIndex >= $scope.pages.length) {
        $scope.pageIndex--;
      }
      return $scope.page = $scope.pages[$scope.pageIndex];
    };
    $scope.addPage = function() {
      var pageNumber;
      pageNumber = $scope.pages.length + 1;
      storyService.addPage("Page " + pageNumber);
      $scope.nextPage();
      return setTimeout(function() {
        return $('#pagetext').focus();
      }, 50);
    };
    $scope.savePage = function() {
      storyService.savePage($scope.page);
      console.log("Page saved");
      return $scope.textEdit = false;
    };
    $scope.googleImage = function() {
      return $scope.imageSearch = true;
    };
    $scope.selectImage = function() {
      return $scope.imageSearch = false;
    };
    return $scope.read = function(word) {
      mediaService.stop();
      if (word === void 0) {
        return;
      }
      if (this.reading === word) {
        return delete reading;
      } else {
        this.reading = word;
        return mediaService.play(this.word.recordingPath, function() {
          return $scope.$apply(function() {
            return delete $scope.word;
          });
        });
      }
    };
  };

  services = ['$scope', '$location', '$routeParams', '$timeout', '$http'];

  if (this.isPhoneGap) {
    services.push('$cordovaFile');
    services.push('$cordovaFileTransfer');
    services.push('$cordovaCamera');
  }

  StoryController.$inject = services;

}).call(this);

},{"./../media-service":8,"./../story-service":11}],13:[function(require,module,exports){
function count(self, substr) {
  var count = 0
  var pos = self.indexOf(substr)

  while (pos >= 0) {
    count += 1
    pos = self.indexOf(substr, pos + 1)
  }

  return count
}

module.exports = count
},{}],14:[function(require,module,exports){
/*
string.js - Copyright (C) 2012-2014, JP Richardson <jprichardson@gmail.com>
*/

!(function() {
  "use strict";

  var VERSION = '3.1.1';

  var ENTITIES = {};

  // from http://semplicewebsites.com/removing-accents-javascript
  var latin_map={"Á":"A","Ă":"A","Ắ":"A","Ặ":"A","Ằ":"A","Ẳ":"A","Ẵ":"A","Ǎ":"A","Â":"A","Ấ":"A","Ậ":"A","Ầ":"A","Ẩ":"A","Ẫ":"A","Ä":"A","Ǟ":"A","Ȧ":"A","Ǡ":"A","Ạ":"A","Ȁ":"A","À":"A","Ả":"A","Ȃ":"A","Ā":"A","Ą":"A","Å":"A","Ǻ":"A","Ḁ":"A","Ⱥ":"A","Ã":"A","Ꜳ":"AA","Æ":"AE","Ǽ":"AE","Ǣ":"AE","Ꜵ":"AO","Ꜷ":"AU","Ꜹ":"AV","Ꜻ":"AV","Ꜽ":"AY","Ḃ":"B","Ḅ":"B","Ɓ":"B","Ḇ":"B","Ƀ":"B","Ƃ":"B","Ć":"C","Č":"C","Ç":"C","Ḉ":"C","Ĉ":"C","Ċ":"C","Ƈ":"C","Ȼ":"C","Ď":"D","Ḑ":"D","Ḓ":"D","Ḋ":"D","Ḍ":"D","Ɗ":"D","Ḏ":"D","ǲ":"D","ǅ":"D","Đ":"D","Ƌ":"D","Ǳ":"DZ","Ǆ":"DZ","É":"E","Ĕ":"E","Ě":"E","Ȩ":"E","Ḝ":"E","Ê":"E","Ế":"E","Ệ":"E","Ề":"E","Ể":"E","Ễ":"E","Ḙ":"E","Ë":"E","Ė":"E","Ẹ":"E","Ȅ":"E","È":"E","Ẻ":"E","Ȇ":"E","Ē":"E","Ḗ":"E","Ḕ":"E","Ę":"E","Ɇ":"E","Ẽ":"E","Ḛ":"E","Ꝫ":"ET","Ḟ":"F","Ƒ":"F","Ǵ":"G","Ğ":"G","Ǧ":"G","Ģ":"G","Ĝ":"G","Ġ":"G","Ɠ":"G","Ḡ":"G","Ǥ":"G","Ḫ":"H","Ȟ":"H","Ḩ":"H","Ĥ":"H","Ⱨ":"H","Ḧ":"H","Ḣ":"H","Ḥ":"H","Ħ":"H","Í":"I","Ĭ":"I","Ǐ":"I","Î":"I","Ï":"I","Ḯ":"I","İ":"I","Ị":"I","Ȉ":"I","Ì":"I","Ỉ":"I","Ȋ":"I","Ī":"I","Į":"I","Ɨ":"I","Ĩ":"I","Ḭ":"I","Ꝺ":"D","Ꝼ":"F","Ᵹ":"G","Ꞃ":"R","Ꞅ":"S","Ꞇ":"T","Ꝭ":"IS","Ĵ":"J","Ɉ":"J","Ḱ":"K","Ǩ":"K","Ķ":"K","Ⱪ":"K","Ꝃ":"K","Ḳ":"K","Ƙ":"K","Ḵ":"K","Ꝁ":"K","Ꝅ":"K","Ĺ":"L","Ƚ":"L","Ľ":"L","Ļ":"L","Ḽ":"L","Ḷ":"L","Ḹ":"L","Ⱡ":"L","Ꝉ":"L","Ḻ":"L","Ŀ":"L","Ɫ":"L","ǈ":"L","Ł":"L","Ǉ":"LJ","Ḿ":"M","Ṁ":"M","Ṃ":"M","Ɱ":"M","Ń":"N","Ň":"N","Ņ":"N","Ṋ":"N","Ṅ":"N","Ṇ":"N","Ǹ":"N","Ɲ":"N","Ṉ":"N","Ƞ":"N","ǋ":"N","Ñ":"N","Ǌ":"NJ","Ó":"O","Ŏ":"O","Ǒ":"O","Ô":"O","Ố":"O","Ộ":"O","Ồ":"O","Ổ":"O","Ỗ":"O","Ö":"O","Ȫ":"O","Ȯ":"O","Ȱ":"O","Ọ":"O","Ő":"O","Ȍ":"O","Ò":"O","Ỏ":"O","Ơ":"O","Ớ":"O","Ợ":"O","Ờ":"O","Ở":"O","Ỡ":"O","Ȏ":"O","Ꝋ":"O","Ꝍ":"O","Ō":"O","Ṓ":"O","Ṑ":"O","Ɵ":"O","Ǫ":"O","Ǭ":"O","Ø":"O","Ǿ":"O","Õ":"O","Ṍ":"O","Ṏ":"O","Ȭ":"O","Ƣ":"OI","Ꝏ":"OO","Ɛ":"E","Ɔ":"O","Ȣ":"OU","Ṕ":"P","Ṗ":"P","Ꝓ":"P","Ƥ":"P","Ꝕ":"P","Ᵽ":"P","Ꝑ":"P","Ꝙ":"Q","Ꝗ":"Q","Ŕ":"R","Ř":"R","Ŗ":"R","Ṙ":"R","Ṛ":"R","Ṝ":"R","Ȑ":"R","Ȓ":"R","Ṟ":"R","Ɍ":"R","Ɽ":"R","Ꜿ":"C","Ǝ":"E","Ś":"S","Ṥ":"S","Š":"S","Ṧ":"S","Ş":"S","Ŝ":"S","Ș":"S","Ṡ":"S","Ṣ":"S","Ṩ":"S","ẞ":"SS","Ť":"T","Ţ":"T","Ṱ":"T","Ț":"T","Ⱦ":"T","Ṫ":"T","Ṭ":"T","Ƭ":"T","Ṯ":"T","Ʈ":"T","Ŧ":"T","Ɐ":"A","Ꞁ":"L","Ɯ":"M","Ʌ":"V","Ꜩ":"TZ","Ú":"U","Ŭ":"U","Ǔ":"U","Û":"U","Ṷ":"U","Ü":"U","Ǘ":"U","Ǚ":"U","Ǜ":"U","Ǖ":"U","Ṳ":"U","Ụ":"U","Ű":"U","Ȕ":"U","Ù":"U","Ủ":"U","Ư":"U","Ứ":"U","Ự":"U","Ừ":"U","Ử":"U","Ữ":"U","Ȗ":"U","Ū":"U","Ṻ":"U","Ų":"U","Ů":"U","Ũ":"U","Ṹ":"U","Ṵ":"U","Ꝟ":"V","Ṿ":"V","Ʋ":"V","Ṽ":"V","Ꝡ":"VY","Ẃ":"W","Ŵ":"W","Ẅ":"W","Ẇ":"W","Ẉ":"W","Ẁ":"W","Ⱳ":"W","Ẍ":"X","Ẋ":"X","Ý":"Y","Ŷ":"Y","Ÿ":"Y","Ẏ":"Y","Ỵ":"Y","Ỳ":"Y","Ƴ":"Y","Ỷ":"Y","Ỿ":"Y","Ȳ":"Y","Ɏ":"Y","Ỹ":"Y","Ź":"Z","Ž":"Z","Ẑ":"Z","Ⱬ":"Z","Ż":"Z","Ẓ":"Z","Ȥ":"Z","Ẕ":"Z","Ƶ":"Z","Ĳ":"IJ","Œ":"OE","ᴀ":"A","ᴁ":"AE","ʙ":"B","ᴃ":"B","ᴄ":"C","ᴅ":"D","ᴇ":"E","ꜰ":"F","ɢ":"G","ʛ":"G","ʜ":"H","ɪ":"I","ʁ":"R","ᴊ":"J","ᴋ":"K","ʟ":"L","ᴌ":"L","ᴍ":"M","ɴ":"N","ᴏ":"O","ɶ":"OE","ᴐ":"O","ᴕ":"OU","ᴘ":"P","ʀ":"R","ᴎ":"N","ᴙ":"R","ꜱ":"S","ᴛ":"T","ⱻ":"E","ᴚ":"R","ᴜ":"U","ᴠ":"V","ᴡ":"W","ʏ":"Y","ᴢ":"Z","á":"a","ă":"a","ắ":"a","ặ":"a","ằ":"a","ẳ":"a","ẵ":"a","ǎ":"a","â":"a","ấ":"a","ậ":"a","ầ":"a","ẩ":"a","ẫ":"a","ä":"a","ǟ":"a","ȧ":"a","ǡ":"a","ạ":"a","ȁ":"a","à":"a","ả":"a","ȃ":"a","ā":"a","ą":"a","ᶏ":"a","ẚ":"a","å":"a","ǻ":"a","ḁ":"a","ⱥ":"a","ã":"a","ꜳ":"aa","æ":"ae","ǽ":"ae","ǣ":"ae","ꜵ":"ao","ꜷ":"au","ꜹ":"av","ꜻ":"av","ꜽ":"ay","ḃ":"b","ḅ":"b","ɓ":"b","ḇ":"b","ᵬ":"b","ᶀ":"b","ƀ":"b","ƃ":"b","ɵ":"o","ć":"c","č":"c","ç":"c","ḉ":"c","ĉ":"c","ɕ":"c","ċ":"c","ƈ":"c","ȼ":"c","ď":"d","ḑ":"d","ḓ":"d","ȡ":"d","ḋ":"d","ḍ":"d","ɗ":"d","ᶑ":"d","ḏ":"d","ᵭ":"d","ᶁ":"d","đ":"d","ɖ":"d","ƌ":"d","ı":"i","ȷ":"j","ɟ":"j","ʄ":"j","ǳ":"dz","ǆ":"dz","é":"e","ĕ":"e","ě":"e","ȩ":"e","ḝ":"e","ê":"e","ế":"e","ệ":"e","ề":"e","ể":"e","ễ":"e","ḙ":"e","ë":"e","ė":"e","ẹ":"e","ȅ":"e","è":"e","ẻ":"e","ȇ":"e","ē":"e","ḗ":"e","ḕ":"e","ⱸ":"e","ę":"e","ᶒ":"e","ɇ":"e","ẽ":"e","ḛ":"e","ꝫ":"et","ḟ":"f","ƒ":"f","ᵮ":"f","ᶂ":"f","ǵ":"g","ğ":"g","ǧ":"g","ģ":"g","ĝ":"g","ġ":"g","ɠ":"g","ḡ":"g","ᶃ":"g","ǥ":"g","ḫ":"h","ȟ":"h","ḩ":"h","ĥ":"h","ⱨ":"h","ḧ":"h","ḣ":"h","ḥ":"h","ɦ":"h","ẖ":"h","ħ":"h","ƕ":"hv","í":"i","ĭ":"i","ǐ":"i","î":"i","ï":"i","ḯ":"i","ị":"i","ȉ":"i","ì":"i","ỉ":"i","ȋ":"i","ī":"i","į":"i","ᶖ":"i","ɨ":"i","ĩ":"i","ḭ":"i","ꝺ":"d","ꝼ":"f","ᵹ":"g","ꞃ":"r","ꞅ":"s","ꞇ":"t","ꝭ":"is","ǰ":"j","ĵ":"j","ʝ":"j","ɉ":"j","ḱ":"k","ǩ":"k","ķ":"k","ⱪ":"k","ꝃ":"k","ḳ":"k","ƙ":"k","ḵ":"k","ᶄ":"k","ꝁ":"k","ꝅ":"k","ĺ":"l","ƚ":"l","ɬ":"l","ľ":"l","ļ":"l","ḽ":"l","ȴ":"l","ḷ":"l","ḹ":"l","ⱡ":"l","ꝉ":"l","ḻ":"l","ŀ":"l","ɫ":"l","ᶅ":"l","ɭ":"l","ł":"l","ǉ":"lj","ſ":"s","ẜ":"s","ẛ":"s","ẝ":"s","ḿ":"m","ṁ":"m","ṃ":"m","ɱ":"m","ᵯ":"m","ᶆ":"m","ń":"n","ň":"n","ņ":"n","ṋ":"n","ȵ":"n","ṅ":"n","ṇ":"n","ǹ":"n","ɲ":"n","ṉ":"n","ƞ":"n","ᵰ":"n","ᶇ":"n","ɳ":"n","ñ":"n","ǌ":"nj","ó":"o","ŏ":"o","ǒ":"o","ô":"o","ố":"o","ộ":"o","ồ":"o","ổ":"o","ỗ":"o","ö":"o","ȫ":"o","ȯ":"o","ȱ":"o","ọ":"o","ő":"o","ȍ":"o","ò":"o","ỏ":"o","ơ":"o","ớ":"o","ợ":"o","ờ":"o","ở":"o","ỡ":"o","ȏ":"o","ꝋ":"o","ꝍ":"o","ⱺ":"o","ō":"o","ṓ":"o","ṑ":"o","ǫ":"o","ǭ":"o","ø":"o","ǿ":"o","õ":"o","ṍ":"o","ṏ":"o","ȭ":"o","ƣ":"oi","ꝏ":"oo","ɛ":"e","ᶓ":"e","ɔ":"o","ᶗ":"o","ȣ":"ou","ṕ":"p","ṗ":"p","ꝓ":"p","ƥ":"p","ᵱ":"p","ᶈ":"p","ꝕ":"p","ᵽ":"p","ꝑ":"p","ꝙ":"q","ʠ":"q","ɋ":"q","ꝗ":"q","ŕ":"r","ř":"r","ŗ":"r","ṙ":"r","ṛ":"r","ṝ":"r","ȑ":"r","ɾ":"r","ᵳ":"r","ȓ":"r","ṟ":"r","ɼ":"r","ᵲ":"r","ᶉ":"r","ɍ":"r","ɽ":"r","ↄ":"c","ꜿ":"c","ɘ":"e","ɿ":"r","ś":"s","ṥ":"s","š":"s","ṧ":"s","ş":"s","ŝ":"s","ș":"s","ṡ":"s","ṣ":"s","ṩ":"s","ʂ":"s","ᵴ":"s","ᶊ":"s","ȿ":"s","ɡ":"g","ß":"ss","ᴑ":"o","ᴓ":"o","ᴝ":"u","ť":"t","ţ":"t","ṱ":"t","ț":"t","ȶ":"t","ẗ":"t","ⱦ":"t","ṫ":"t","ṭ":"t","ƭ":"t","ṯ":"t","ᵵ":"t","ƫ":"t","ʈ":"t","ŧ":"t","ᵺ":"th","ɐ":"a","ᴂ":"ae","ǝ":"e","ᵷ":"g","ɥ":"h","ʮ":"h","ʯ":"h","ᴉ":"i","ʞ":"k","ꞁ":"l","ɯ":"m","ɰ":"m","ᴔ":"oe","ɹ":"r","ɻ":"r","ɺ":"r","ⱹ":"r","ʇ":"t","ʌ":"v","ʍ":"w","ʎ":"y","ꜩ":"tz","ú":"u","ŭ":"u","ǔ":"u","û":"u","ṷ":"u","ü":"u","ǘ":"u","ǚ":"u","ǜ":"u","ǖ":"u","ṳ":"u","ụ":"u","ű":"u","ȕ":"u","ù":"u","ủ":"u","ư":"u","ứ":"u","ự":"u","ừ":"u","ử":"u","ữ":"u","ȗ":"u","ū":"u","ṻ":"u","ų":"u","ᶙ":"u","ů":"u","ũ":"u","ṹ":"u","ṵ":"u","ᵫ":"ue","ꝸ":"um","ⱴ":"v","ꝟ":"v","ṿ":"v","ʋ":"v","ᶌ":"v","ⱱ":"v","ṽ":"v","ꝡ":"vy","ẃ":"w","ŵ":"w","ẅ":"w","ẇ":"w","ẉ":"w","ẁ":"w","ⱳ":"w","ẘ":"w","ẍ":"x","ẋ":"x","ᶍ":"x","ý":"y","ŷ":"y","ÿ":"y","ẏ":"y","ỵ":"y","ỳ":"y","ƴ":"y","ỷ":"y","ỿ":"y","ȳ":"y","ẙ":"y","ɏ":"y","ỹ":"y","ź":"z","ž":"z","ẑ":"z","ʑ":"z","ⱬ":"z","ż":"z","ẓ":"z","ȥ":"z","ẕ":"z","ᵶ":"z","ᶎ":"z","ʐ":"z","ƶ":"z","ɀ":"z","ﬀ":"ff","ﬃ":"ffi","ﬄ":"ffl","ﬁ":"fi","ﬂ":"fl","ĳ":"ij","œ":"oe","ﬆ":"st","ₐ":"a","ₑ":"e","ᵢ":"i","ⱼ":"j","ₒ":"o","ᵣ":"r","ᵤ":"u","ᵥ":"v","ₓ":"x"};

//******************************************************************************
// Added an initialize function which is essentially the code from the S
// constructor.  Now, the S constructor calls this and a new method named
// setValue calls it as well.  The setValue function allows constructors for
// modules that extend string.js to set the initial value of an object without
// knowing the internal workings of string.js.
//
// Also, all methods which return a new S object now call:
//
//      return new this.constructor(s);
//
// instead of:
//
//      return new S(s);
//
// This allows extended objects to keep their proper instanceOf and constructor.
//******************************************************************************

  function initialize (object, s) {
    if (s !== null && s !== undefined) {
      if (typeof s === 'string')
        object.s = s;
      else
        object.s = s.toString();
    } else {
      object.s = s; //null or undefined
    }

    object.orig = s; //original object, currently only used by toCSV() and toBoolean()

    if (s !== null && s !== undefined) {
      if (object.__defineGetter__) {
        object.__defineGetter__('length', function() {
          return object.s.length;
        })
      } else {
        object.length = s.length;
      }
    } else {
      object.length = -1;
    }
  }

  function S(s) {
  	initialize(this, s);
  }

  var __nsp = String.prototype;
  var __sp = S.prototype = {

    between: function(left, right) {
      var s = this.s;
      var startPos = s.indexOf(left);
      var endPos = s.indexOf(right, startPos + left.length);
      if (endPos == -1 && right != null)
        return new this.constructor('')
      else if (endPos == -1 && right == null)
        return new this.constructor(s.substring(startPos + left.length))
      else
        return new this.constructor(s.slice(startPos + left.length, endPos));
    },

    //# modified slightly from https://github.com/epeli/underscore.string
    camelize: function() {
      var s = this.trim().s.replace(/(\-|_|\s)+(.)?/g, function(mathc, sep, c) {
        return (c ? c.toUpperCase() : '');
      });
      return new this.constructor(s);
    },

    capitalize: function() {
      return new this.constructor(this.s.substr(0, 1).toUpperCase() + this.s.substring(1).toLowerCase());
    },

    charAt: function(index) {
      return this.s.charAt(index);
    },

    chompLeft: function(prefix) {
      var s = this.s;
      if (s.indexOf(prefix) === 0) {
         s = s.slice(prefix.length);
         return new this.constructor(s);
      } else {
        return this;
      }
    },

    chompRight: function(suffix) {
      if (this.endsWith(suffix)) {
        var s = this.s;
        s = s.slice(0, s.length - suffix.length);
        return new this.constructor(s);
      } else {
        return this;
      }
    },

    //#thanks Google
    collapseWhitespace: function() {
      var s = this.s.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
      return new this.constructor(s);
    },

    contains: function(ss) {
      return this.s.indexOf(ss) >= 0;
    },

    count: function(ss) {
      return require('./_count')(this.s, ss)
    },

    //#modified from https://github.com/epeli/underscore.string
    dasherize: function() {
      var s = this.trim().s.replace(/[_\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').toLowerCase();
      return new this.constructor(s);
    },

    latinise: function() {
      var s = this.replace(/[^A-Za-z0-9\[\] ]/g, function(x) { return latin_map[x] || x; });
      return new this.constructor(s);
    },

    decodeHtmlEntities: function() { //https://github.com/substack/node-ent/blob/master/index.js
      var s = this.s;
      s = s.replace(/&#(\d+);?/g, function (_, code) {
        return String.fromCharCode(code);
      })
      .replace(/&#[xX]([A-Fa-f0-9]+);?/g, function (_, hex) {
        return String.fromCharCode(parseInt(hex, 16));
      })
      .replace(/&([^;\W]+;?)/g, function (m, e) {
        var ee = e.replace(/;$/, '');
        var target = ENTITIES[e] || (e.match(/;$/) && ENTITIES[ee]);

        if (typeof target === 'number') {
          return String.fromCharCode(target);
        }
        else if (typeof target === 'string') {
          return target;
        }
        else {
          return m;
        }
      })

      return new this.constructor(s);
    },

    endsWith: function() {
      var suffixes = Array.prototype.slice.call(arguments, 0);
      for (var i = 0; i < suffixes.length; ++i) {
        var l  = this.s.length - suffixes[i].length;
        if (l >= 0 && this.s.indexOf(suffixes[i], l) === l) return true;
      }
      return false;
    },

    escapeHTML: function() { //from underscore.string
      return new this.constructor(this.s.replace(/[&<>"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; }));
    },

    ensureLeft: function(prefix) {
      var s = this.s;
      if (s.indexOf(prefix) === 0) {
        return this;
      } else {
        return new this.constructor(prefix + s);
      }
    },

    ensureRight: function(suffix) {
      var s = this.s;
      if (this.endsWith(suffix))  {
        return this;
      } else {
        return new this.constructor(s + suffix);
      }
    },

    humanize: function() { //modified from underscore.string
      if (this.s === null || this.s === undefined)
        return new this.constructor('')
      var s = this.underscore().replace(/_id$/,'').replace(/_/g, ' ').trim().capitalize()
      return new this.constructor(s)
    },

    isAlpha: function() {
      return !/[^a-z\xDF-\xFF]|^$/.test(this.s.toLowerCase());
    },

    isAlphaNumeric: function() {
      return !/[^0-9a-z\xDF-\xFF]/.test(this.s.toLowerCase());
    },

    isEmpty: function() {
      return this.s === null || this.s === undefined ? true : /^[\s\xa0]*$/.test(this.s);
    },

    isLower: function() {
      return this.isAlpha() && this.s.toLowerCase() === this.s;
    },

    isNumeric: function() {
      return !/[^0-9]/.test(this.s);
    },

    isUpper: function() {
      return this.isAlpha() && this.s.toUpperCase() === this.s;
    },

    left: function(N) {
      if (N >= 0) {
        var s = this.s.substr(0, N);
        return new this.constructor(s);
      } else {
        return this.right(-N);
      }
    },

    lines: function() { //convert windows newlines to unix newlines then convert to an Array of lines
      return this.replaceAll('\r\n', '\n').s.split('\n');
    },

    pad: function(len, ch) { //https://github.com/component/pad
      if (ch == null) ch = ' ';
      if (this.s.length >= len) return new this.constructor(this.s);
      len = len - this.s.length;
      var left = Array(Math.ceil(len / 2) + 1).join(ch);
      var right = Array(Math.floor(len / 2) + 1).join(ch);
      return new this.constructor(left + this.s + right);
    },

    padLeft: function(len, ch) { //https://github.com/component/pad
      if (ch == null) ch = ' ';
      if (this.s.length >= len) return new this.constructor(this.s);
      return new this.constructor(Array(len - this.s.length + 1).join(ch) + this.s);
    },

    padRight: function(len, ch) { //https://github.com/component/pad
      if (ch == null) ch = ' ';
      if (this.s.length >= len) return new this.constructor(this.s);
      return new this.constructor(this.s + Array(len - this.s.length + 1).join(ch));
    },

    parseCSV: function(delimiter, qualifier, escape, lineDelimiter) { //try to parse no matter what
      delimiter = delimiter || ',';
      escape = escape || '\\'
      if (typeof qualifier == 'undefined')
        qualifier = '"';

      var i = 0, fieldBuffer = [], fields = [], len = this.s.length, inField = false, inUnqualifiedString = false, self = this;
      var ca = function(i){return self.s.charAt(i)};
      if (typeof lineDelimiter !== 'undefined') var rows = [];

      if (!qualifier)
        inField = true;

      while (i < len) {
        var current = ca(i);
        switch (current) {
          case escape:
            //fix for issues #32 and #35
            if (inField && ((escape !== qualifier) || ca(i+1) === qualifier)) {
              i += 1;
              fieldBuffer.push(ca(i));
              break;
            }
            if (escape !== qualifier) break;
          case qualifier:
            inField = !inField;
            break;
          case delimiter:
            if(inUnqualifiedString) {
              inField=false;
              inUnqualifiedString=false;
            }
            if (inField && qualifier)
              fieldBuffer.push(current);
            else {
              fields.push(fieldBuffer.join(''))
              fieldBuffer.length = 0;
            }
            break;
          case lineDelimiter:
            if(inUnqualifiedString) {
              inField=false;
              inUnqualifiedString=false;
              fields.push(fieldBuffer.join(''))
              rows.push(fields);
              fields = [];
              fieldBuffer.length = 0;
            }
            else if (inField) {
              fieldBuffer.push(current);
            } else {
              if (rows) {
                fields.push(fieldBuffer.join(''))
                rows.push(fields);
                fields = [];
                fieldBuffer.length = 0;
              }
            }
            break;
          case ' ':
            if (inField)
              fieldBuffer.push(current);
            break;
          default:
            if (inField)
              fieldBuffer.push(current);
            else if(current!==qualifier) {
              fieldBuffer.push(current);
              inField=true;
              inUnqualifiedString=true;
            }
            break;
        }
        i += 1;
      }

      fields.push(fieldBuffer.join(''));
      if (rows) {
        rows.push(fields);
        return rows;
      }
      return fields;
    },

    replaceAll: function(ss, r) {
      //var s = this.s.replace(new RegExp(ss, 'g'), r);
      var s = this.s.split(ss).join(r)
      return new this.constructor(s);
    },

    strip: function() {
      var ss = this.s;
      for(var i= 0, n=arguments.length; i<n; i++) {
        ss = ss.split(arguments[i]).join('');
      }
      return new this.constructor(ss);
    },

    stripLeft: function (chars) {
      var regex;
      var pattern;
      var ss = ensureString(this.s);

      if (chars === undefined) {
        pattern = /^\s+/g;
      }
      else {
        regex = escapeRegExp(chars);
        pattern = new RegExp("^[" + regex + "]+", "g");
      }

      return new this.constructor(ss.replace(pattern, ""));
    },

    stripRight: function (chars) {
      var regex;
      var pattern;
      var ss = ensureString(this.s);

      if (chars === undefined) {
        pattern = /\s+$/g;
      }
      else {
        regex = escapeRegExp(chars);
        pattern = new RegExp("[" + regex + "]+$", "g");
      }

      return new this.constructor(ss.replace(pattern, ""));
    },

    right: function(N) {
      if (N >= 0) {
        var s = this.s.substr(this.s.length - N, N);
        return new this.constructor(s);
      } else {
        return this.left(-N);
      }
    },

    setValue: function (s) {
	  initialize(this, s);
	  return this;
    },

    slugify: function() {
      var sl = (new S(new S(this.s).latinise().s.replace(/[^\w\s-]/g, '').toLowerCase())).dasherize().s;
      if (sl.charAt(0) === '-')
        sl = sl.substr(1);
      return new this.constructor(sl);
    },

    startsWith: function() {
      var prefixes = Array.prototype.slice.call(arguments, 0);
      for (var i = 0; i < prefixes.length; ++i) {
        if (this.s.lastIndexOf(prefixes[i], 0) === 0) return true;
      }
      return false;
    },

    stripPunctuation: function() {
      //return new this.constructor(this.s.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g,""));
      return new this.constructor(this.s.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " "));
    },

    stripTags: function() { //from sugar.js
      var s = this.s, args = arguments.length > 0 ? arguments : [''];
      multiArgs(args, function(tag) {
        s = s.replace(RegExp('<\/?' + tag + '[^<>]*>', 'gi'), '');
      });
      return new this.constructor(s);
    },

    template: function(values, opening, closing) {
      var s = this.s
      var opening = opening || Export.TMPL_OPEN
      var closing = closing || Export.TMPL_CLOSE

      var open = opening.replace(/[-[\]()*\s]/g, "\\$&").replace(/\$/g, '\\$')
      var close = closing.replace(/[-[\]()*\s]/g, "\\$&").replace(/\$/g, '\\$')
      var r = new RegExp(open + '(.+?)' + close, 'g')
        //, r = /\{\{(.+?)\}\}/g
      var matches = s.match(r) || [];

      matches.forEach(function(match) {
        var key = match.substring(opening.length, match.length - closing.length).trim();//chop {{ and }}
        var value = typeof values[key] == 'undefined' ? '' : values[key];
        s = s.replace(match, value);
      });
      return new this.constructor(s);
    },

    times: function(n) {
      return new this.constructor(new Array(n + 1).join(this.s));
    },

    toBoolean: function() {
      if (typeof this.orig === 'string') {
        var s = this.s.toLowerCase();
        return s === 'true' || s === 'yes' || s === 'on' || s === '1';
      } else
        return this.orig === true || this.orig === 1;
    },

    toFloat: function(precision) {
      var num = parseFloat(this.s)
      if (precision)
        return parseFloat(num.toFixed(precision))
      else
        return num
    },

    toInt: function() { //thanks Google
      // If the string starts with '0x' or '-0x', parse as hex.
      return /^\s*-?0x/i.test(this.s) ? parseInt(this.s, 16) : parseInt(this.s, 10)
    },

    trim: function() {
      var s;
      if (typeof __nsp.trim === 'undefined')
        s = this.s.replace(/(^\s*|\s*$)/g, '')
      else
        s = this.s.trim()
      return new this.constructor(s);
    },

    trimLeft: function() {
      var s;
      if (__nsp.trimLeft)
        s = this.s.trimLeft();
      else
        s = this.s.replace(/(^\s*)/g, '');
      return new this.constructor(s);
    },

    trimRight: function() {
      var s;
      if (__nsp.trimRight)
        s = this.s.trimRight();
      else
        s = this.s.replace(/\s+$/, '');
      return new this.constructor(s);
    },

    truncate: function(length, pruneStr) { //from underscore.string, author: github.com/rwz
      var str = this.s;

      length = ~~length;
      pruneStr = pruneStr || '...';

      if (str.length <= length) return new this.constructor(str);

      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },
        template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

      if (template.slice(template.length-2).match(/\w\w/))
        template = template.replace(/\s*\S+$/, '');
      else
        template = new S(template.slice(0, template.length-1)).trimRight().s;

      return (template+pruneStr).length > str.length ? new S(str) : new S(str.slice(0, template.length)+pruneStr);
    },

    toCSV: function() {
      var delim = ',', qualifier = '"', escape = '\\', encloseNumbers = true, keys = false;
      var dataArray = [];

      function hasVal(it) {
        return it !== null && it !== '';
      }

      if (typeof arguments[0] === 'object') {
        delim = arguments[0].delimiter || delim;
        delim = arguments[0].separator || delim;
        qualifier = arguments[0].qualifier || qualifier;
        encloseNumbers = !!arguments[0].encloseNumbers;
        escape = arguments[0].escape || escape;
        keys = !!arguments[0].keys;
      } else if (typeof arguments[0] === 'string') {
        delim = arguments[0];
      }

      if (typeof arguments[1] === 'string')
        qualifier = arguments[1];

      if (arguments[1] === null)
        qualifier = null;

       if (this.orig instanceof Array)
        dataArray  = this.orig;
      else { //object
        for (var key in this.orig)
          if (this.orig.hasOwnProperty(key))
            if (keys)
              dataArray.push(key);
            else
              dataArray.push(this.orig[key]);
      }

      var rep = escape + qualifier;
      var buildString = [];
      for (var i = 0; i < dataArray.length; ++i) {
        var shouldQualify = hasVal(qualifier)
        if (typeof dataArray[i] == 'number')
          shouldQualify &= encloseNumbers;

        if (shouldQualify)
          buildString.push(qualifier);

        if (dataArray[i] !== null && dataArray[i] !== undefined) {
          var d = new S(dataArray[i]).replaceAll(qualifier, rep).s;
          buildString.push(d);
        } else
          buildString.push('')

        if (shouldQualify)
          buildString.push(qualifier);

        if (delim)
          buildString.push(delim);
      }

      //chop last delim
      //console.log(buildString.length)
      buildString.length = buildString.length - 1;
      return new this.constructor(buildString.join(''));
    },

    toString: function() {
      return this.s;
    },

    //#modified from https://github.com/epeli/underscore.string
    underscore: function() {
      var s = this.trim().s.replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/([A-Z\d]+)([A-Z][a-z])/,'$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
      return new this.constructor(s);
    },

    unescapeHTML: function() { //from underscore.string
      return new this.constructor(this.s.replace(/\&([^;]+);/g, function(entity, entityCode){
        var match;

        if (entityCode in escapeChars) {
          return escapeChars[entityCode];
        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
          return String.fromCharCode(parseInt(match[1], 16));
        } else if (match = entityCode.match(/^#(\d+)$/)) {
          return String.fromCharCode(~~match[1]);
        } else {
          return entity;
        }
      }));
    },

    valueOf: function() {
      return this.s.valueOf();
    },

    //#Added a New Function called wrapHTML.
    wrapHTML: function (tagName, tagAttrs) {
      var s = this.s, el = (tagName == null) ? 'span' : tagName, elAttr = '', wrapped = '';
      if(typeof tagAttrs == 'object') for(var prop in tagAttrs) elAttr += ' ' + prop + '="' +(new this.constructor(tagAttrs[prop])).escapeHTML() + '"';
      s = wrapped.concat('<', el, elAttr, '>', this, '</', el, '>');
      return new this.constructor(s);
    }
  }

  var methodsAdded = [];
  function extendPrototype() {
    for (var name in __sp) {
      (function(name){
        var func = __sp[name];
        if (!__nsp.hasOwnProperty(name)) {
          methodsAdded.push(name);
          __nsp[name] = function() {
            String.prototype.s = this;
            return func.apply(this, arguments);
          }
        }
      })(name);
    }
  }

  function restorePrototype() {
    for (var i = 0; i < methodsAdded.length; ++i)
      delete String.prototype[methodsAdded[i]];
    methodsAdded.length = 0;
  }


/*************************************
/* Attach Native JavaScript String Properties
/*************************************/

  var nativeProperties = getNativeStringProperties();
  for (var name in nativeProperties) {
    (function(name) {
      var stringProp = __nsp[name];
      if (typeof stringProp == 'function') {
        //console.log(stringProp)
        if (!__sp[name]) {
          if (nativeProperties[name] === 'string') {
            __sp[name] = function() {
              //console.log(name)
              return new this.constructor(stringProp.apply(this, arguments));
            }
          } else {
            __sp[name] = stringProp;
          }
        }
      }
    })(name);
  }


/*************************************
/* Function Aliases
/*************************************/

  __sp.repeat = __sp.times;
  __sp.include = __sp.contains;
  __sp.toInteger = __sp.toInt;
  __sp.toBool = __sp.toBoolean;
  __sp.decodeHTMLEntities = __sp.decodeHtmlEntities //ensure consistent casing scheme of 'HTML'


//******************************************************************************
// Set the constructor.  Without this, string.js objects are instances of
// Object instead of S.
//******************************************************************************

  __sp.constructor = S;


/*************************************
/* Private Functions
/*************************************/

  function getNativeStringProperties() {
    var names = getNativeStringPropertyNames();
    var retObj = {};

    for (var i = 0; i < names.length; ++i) {
      var name = names[i];
      var func = __nsp[name];
      try {
        // #127: pass extra parameter to keep shelljs happy
        var type = typeof func.apply('test', ['string']);
        retObj[name] = type;
      } catch (e) {}
    }
    return retObj;
  }

  function getNativeStringPropertyNames() {
    var results = [];
    if (Object.getOwnPropertyNames) {
      results = Object.getOwnPropertyNames(__nsp);
      results.splice(results.indexOf('valueOf'), 1);
      results.splice(results.indexOf('toString'), 1);
      return results;
    } else { //meant for legacy cruft, this could probably be made more efficient
      var stringNames = {};
      var objectNames = [];
      for (var name in String.prototype)
        stringNames[name] = name;

      for (var name in Object.prototype)
        delete stringNames[name];

      //stringNames['toString'] = 'toString'; //this was deleted with the rest of the object names
      for (var name in stringNames) {
        results.push(name);
      }
      return results;
    }
  }

  function Export(str) {
    return new S(str);
  };

  //attach exports to StringJSWrapper
  Export.extendPrototype = extendPrototype;
  Export.restorePrototype = restorePrototype;
  Export.VERSION = VERSION;
  Export.TMPL_OPEN = '{{';
  Export.TMPL_CLOSE = '}}';
  Export.ENTITIES = ENTITIES;



/*************************************
/* Exports
/*************************************/

  if (typeof module !== 'undefined'  && typeof module.exports !== 'undefined') {
    module.exports = Export;

  } else {

    if(typeof define === "function" && define.amd) {
      define([], function() {
        return Export;
      });
    } else {
      window.S = Export;
    }
  }


/*************************************
/* 3rd Party Private Functions
/*************************************/

  //from sugar.js
  function multiArgs(args, fn) {
    var result = [], i;
    for(i = 0; i < args.length; i++) {
      result.push(args[i]);
      if(fn) fn.call(args, args[i], i);
    }
    return result;
  }

  //from underscore.string
  var escapeChars = {
    lt: '<',
    gt: '>',
    quot: '"',
    apos: "'",
    amp: '&'
  };

  function escapeRegExp (s) {
    // most part from https://github.com/skulpt/skulpt/blob/ecaf75e69c2e539eff124b2ab45df0b01eaf2295/src/str.js#L242
    var c;
    var i;
    var ret = [];
    var re = /^[A-Za-z0-9]+$/;
    s = ensureString(s);
    for (i = 0; i < s.length; ++i) {
      c = s.charAt(i);

      if (re.test(c)) {
        ret.push(c);
      }
      else {
        if (c === "\\000") {
          ret.push("\\000");
        }
        else {
          ret.push("\\" + c);
        }
      }
    }
    return ret.join("");
  }

  function ensureString(string) {
    return string == null ? '' : '' + string;
  }

  //from underscore.string
  var reversedEscapeChars = {};
  for(var key in escapeChars){ reversedEscapeChars[escapeChars[key]] = key; }

  ENTITIES = {
    "amp" : "&",
    "gt" : ">",
    "lt" : "<",
    "quot" : "\"",
    "apos" : "'",
    "AElig" : 198,
    "Aacute" : 193,
    "Acirc" : 194,
    "Agrave" : 192,
    "Aring" : 197,
    "Atilde" : 195,
    "Auml" : 196,
    "Ccedil" : 199,
    "ETH" : 208,
    "Eacute" : 201,
    "Ecirc" : 202,
    "Egrave" : 200,
    "Euml" : 203,
    "Iacute" : 205,
    "Icirc" : 206,
    "Igrave" : 204,
    "Iuml" : 207,
    "Ntilde" : 209,
    "Oacute" : 211,
    "Ocirc" : 212,
    "Ograve" : 210,
    "Oslash" : 216,
    "Otilde" : 213,
    "Ouml" : 214,
    "THORN" : 222,
    "Uacute" : 218,
    "Ucirc" : 219,
    "Ugrave" : 217,
    "Uuml" : 220,
    "Yacute" : 221,
    "aacute" : 225,
    "acirc" : 226,
    "aelig" : 230,
    "agrave" : 224,
    "aring" : 229,
    "atilde" : 227,
    "auml" : 228,
    "ccedil" : 231,
    "eacute" : 233,
    "ecirc" : 234,
    "egrave" : 232,
    "eth" : 240,
    "euml" : 235,
    "iacute" : 237,
    "icirc" : 238,
    "igrave" : 236,
    "iuml" : 239,
    "ntilde" : 241,
    "oacute" : 243,
    "ocirc" : 244,
    "ograve" : 242,
    "oslash" : 248,
    "otilde" : 245,
    "ouml" : 246,
    "szlig" : 223,
    "thorn" : 254,
    "uacute" : 250,
    "ucirc" : 251,
    "ugrave" : 249,
    "uuml" : 252,
    "yacute" : 253,
    "yuml" : 255,
    "copy" : 169,
    "reg" : 174,
    "nbsp" : 160,
    "iexcl" : 161,
    "cent" : 162,
    "pound" : 163,
    "curren" : 164,
    "yen" : 165,
    "brvbar" : 166,
    "sect" : 167,
    "uml" : 168,
    "ordf" : 170,
    "laquo" : 171,
    "not" : 172,
    "shy" : 173,
    "macr" : 175,
    "deg" : 176,
    "plusmn" : 177,
    "sup1" : 185,
    "sup2" : 178,
    "sup3" : 179,
    "acute" : 180,
    "micro" : 181,
    "para" : 182,
    "middot" : 183,
    "cedil" : 184,
    "ordm" : 186,
    "raquo" : 187,
    "frac14" : 188,
    "frac12" : 189,
    "frac34" : 190,
    "iquest" : 191,
    "times" : 215,
    "divide" : 247,
    "OElig;" : 338,
    "oelig;" : 339,
    "Scaron;" : 352,
    "scaron;" : 353,
    "Yuml;" : 376,
    "fnof;" : 402,
    "circ;" : 710,
    "tilde;" : 732,
    "Alpha;" : 913,
    "Beta;" : 914,
    "Gamma;" : 915,
    "Delta;" : 916,
    "Epsilon;" : 917,
    "Zeta;" : 918,
    "Eta;" : 919,
    "Theta;" : 920,
    "Iota;" : 921,
    "Kappa;" : 922,
    "Lambda;" : 923,
    "Mu;" : 924,
    "Nu;" : 925,
    "Xi;" : 926,
    "Omicron;" : 927,
    "Pi;" : 928,
    "Rho;" : 929,
    "Sigma;" : 931,
    "Tau;" : 932,
    "Upsilon;" : 933,
    "Phi;" : 934,
    "Chi;" : 935,
    "Psi;" : 936,
    "Omega;" : 937,
    "alpha;" : 945,
    "beta;" : 946,
    "gamma;" : 947,
    "delta;" : 948,
    "epsilon;" : 949,
    "zeta;" : 950,
    "eta;" : 951,
    "theta;" : 952,
    "iota;" : 953,
    "kappa;" : 954,
    "lambda;" : 955,
    "mu;" : 956,
    "nu;" : 957,
    "xi;" : 958,
    "omicron;" : 959,
    "pi;" : 960,
    "rho;" : 961,
    "sigmaf;" : 962,
    "sigma;" : 963,
    "tau;" : 964,
    "upsilon;" : 965,
    "phi;" : 966,
    "chi;" : 967,
    "psi;" : 968,
    "omega;" : 969,
    "thetasym;" : 977,
    "upsih;" : 978,
    "piv;" : 982,
    "ensp;" : 8194,
    "emsp;" : 8195,
    "thinsp;" : 8201,
    "zwnj;" : 8204,
    "zwj;" : 8205,
    "lrm;" : 8206,
    "rlm;" : 8207,
    "ndash;" : 8211,
    "mdash;" : 8212,
    "lsquo;" : 8216,
    "rsquo;" : 8217,
    "sbquo;" : 8218,
    "ldquo;" : 8220,
    "rdquo;" : 8221,
    "bdquo;" : 8222,
    "dagger;" : 8224,
    "Dagger;" : 8225,
    "bull;" : 8226,
    "hellip;" : 8230,
    "permil;" : 8240,
    "prime;" : 8242,
    "Prime;" : 8243,
    "lsaquo;" : 8249,
    "rsaquo;" : 8250,
    "oline;" : 8254,
    "frasl;" : 8260,
    "euro;" : 8364,
    "image;" : 8465,
    "weierp;" : 8472,
    "real;" : 8476,
    "trade;" : 8482,
    "alefsym;" : 8501,
    "larr;" : 8592,
    "uarr;" : 8593,
    "rarr;" : 8594,
    "darr;" : 8595,
    "harr;" : 8596,
    "crarr;" : 8629,
    "lArr;" : 8656,
    "uArr;" : 8657,
    "rArr;" : 8658,
    "dArr;" : 8659,
    "hArr;" : 8660,
    "forall;" : 8704,
    "part;" : 8706,
    "exist;" : 8707,
    "empty;" : 8709,
    "nabla;" : 8711,
    "isin;" : 8712,
    "notin;" : 8713,
    "ni;" : 8715,
    "prod;" : 8719,
    "sum;" : 8721,
    "minus;" : 8722,
    "lowast;" : 8727,
    "radic;" : 8730,
    "prop;" : 8733,
    "infin;" : 8734,
    "ang;" : 8736,
    "and;" : 8743,
    "or;" : 8744,
    "cap;" : 8745,
    "cup;" : 8746,
    "int;" : 8747,
    "there4;" : 8756,
    "sim;" : 8764,
    "cong;" : 8773,
    "asymp;" : 8776,
    "ne;" : 8800,
    "equiv;" : 8801,
    "le;" : 8804,
    "ge;" : 8805,
    "sub;" : 8834,
    "sup;" : 8835,
    "nsub;" : 8836,
    "sube;" : 8838,
    "supe;" : 8839,
    "oplus;" : 8853,
    "otimes;" : 8855,
    "perp;" : 8869,
    "sdot;" : 8901,
    "lceil;" : 8968,
    "rceil;" : 8969,
    "lfloor;" : 8970,
    "rfloor;" : 8971,
    "lang;" : 9001,
    "rang;" : 9002,
    "loz;" : 9674,
    "spades;" : 9824,
    "clubs;" : 9827,
    "hearts;" : 9829,
    "diams;" : 9830
  }


}).call(this);

},{"./_count":13}],15:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL1VzZXJzL2tvcnplbmwvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiZ2VuL2FwcC5qcyIsImdlbi9kaXJlY3RpdmVzLmpzIiwiZ2VuL2VkaXQvZWRpdC5qcyIsImdlbi9lZGl0L3N0b3J5LXBhcnNlci5qcyIsImdlbi9maWxlLXNlcnZpY2UuanMiLCJnZW4vaG9tZS9ob21lLmpzIiwiZ2VuL2luZGV4LWNvbnRyb2xsZXIuanMiLCJnZW4vbWVkaWEtc2VydmljZS5qcyIsImdlbi9yZWNvcmRpbmcvcmVjb3JkaW5nLmpzIiwiZ2VuL3N0b3JhZ2Utc2VydmljZS5qcyIsImdlbi9zdG9yeS1zZXJ2aWNlLmpzIiwiZ2VuL3N0b3J5L3N0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZy9saWIvX2NvdW50LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZy9saWIvc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgYXBwLCBtb2R1bGVzO1xuXG4gIHRoaXMuaXNQaG9uZUdhcCA9IGRvY3VtZW50LlVSTC5pbmRleE9mKCdodHRwOi8vJykgPT09IC0xICYmIGRvY3VtZW50LlVSTC5pbmRleE9mKCdodHRwczovLycpID09PSAtMTtcblxuICBtb2R1bGVzID0gWyduZ1JvdXRlJywgJ25nVG91Y2gnLCAnbW9ub3NwYWNlZC5lbGFzdGljJ107XG5cbiAgaWYgKHRoaXMuaXNQaG9uZUdhcCkge1xuICAgIG1vZHVsZXMucHVzaCgnbmdDb3Jkb3ZhJyk7XG4gIH1cblxuICBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnUHVibGljQXBwJywgbW9kdWxlcyk7XG5cbiAgYXBwLmNvbnRyb2xsZXIoJ0luZGV4Q29udHJvbGxlcicsIHJlcXVpcmUoJy4vaW5kZXgtY29udHJvbGxlcicpKTtcblxuICBhcHAuZGlyZWN0aXZlKCd0YXAnLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMnKS50YXApO1xuXG4gIGFwcC5kaXJlY3RpdmUoJ25nRW50ZXInLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMnKS5lbnRlcik7XG5cbiAgYXBwLmNvbmZpZyhbXG4gICAgJyRodHRwUHJvdmlkZXInLCAnJHJvdXRlUHJvdmlkZXInLCBmdW5jdGlvbigkaHR0cFByb3ZpZGVyLCAkcm91dGVQcm92aWRlcikge1xuICAgICAgcmV0dXJuICRyb3V0ZVByb3ZpZGVyLndoZW4oJy8nLCB7XG4gICAgICAgIGNvbnRyb2xsZXI6IHJlcXVpcmUoJy4vaG9tZS9ob21lJyksXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnaG9tZS9ob21lLmh0bWwnXG4gICAgICB9KS53aGVuKCcvc3RvcnkvOmlkLzpvcHQ/LzpyZWM/Jywge1xuICAgICAgICBjb250cm9sbGVyOiByZXF1aXJlKCcuL3N0b3J5L3N0b3J5JyksXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnc3Rvcnkvc3RvcnkuaHRtbCdcbiAgICAgIH0pLndoZW4oJy9lZGl0LzppZCcsIHtcbiAgICAgICAgY29udHJvbGxlcjogcmVxdWlyZSgnLi9lZGl0L2VkaXQnKSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdlZGl0L2VkaXQuaHRtbCdcbiAgICAgIH0pLndoZW4oJy9yZWNvcmQnLCB7XG4gICAgICAgIGNvbnRyb2xsZXI6IHJlcXVpcmUoJy4vcmVjb3JkaW5nL3JlY29yZGluZycpLFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ3JlY29yZGluZy9yZWNvcmRpbmcuaHRtbCdcbiAgICAgIH0pLm90aGVyd2lzZSh7XG4gICAgICAgIHJlZGlyZWN0VG86ICcvJ1xuICAgICAgfSk7XG4gICAgfVxuICBdKTtcblxuICBpZiAodGhpcy5pc1Bob25lR2FwKSB7XG4gICAgY29uc29sZS5sb2coXCJQSE9ORUdBUCBBUFBMSUNBVElPTlwiKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFuZ3VsYXIuYm9vdHN0cmFwKGRvY3VtZW50LCBbJ1B1YmxpY0FwcCddKTtcbiAgICB9LCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coXCJCUk9XU0VSXCIpO1xuICAgIGFuZ3VsYXIuYm9vdHN0cmFwKGRvY3VtZW50LCBbJ1B1YmxpY0FwcCddKTtcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gYXBwO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMFxuKGZ1bmN0aW9uKCkge1xuICBleHBvcnRzLnRhcCA9IGZ1bmN0aW9uKCR0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbSwgYXR0cikge1xuICAgICAgICByZXR1cm4gZWxlbS5vbigndG91Y2hlbmQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBjb29sZG93biwgX3JlZiwgX3JlZjE7XG4gICAgICAgICAgaWYgKGNvb2xkb3duKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvb2xkb3duID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5pc1Bob25lR2FwICYmICgoX3JlZiA9IHdpbmRvdy5wbHVnaW5zKSAhPSBudWxsID8gKF9yZWYxID0gX3JlZi5kZXZpY2VGZWVkYmFjaykgIT0gbnVsbCA/IF9yZWYxLmFjb3VzdGljIDogdm9pZCAwIDogdm9pZCAwKSkge1xuICAgICAgICAgICAgd2luZG93LnBsdWdpbnMuZGV2aWNlRmVlZGJhY2suYWNvdXN0aWMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBlbGVtLnJlbW92ZUNsYXNzKCd0YXBwZWQnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvb2xkb3duID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgIHJldHVybiBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlbGVtLmFkZENsYXNzKCd0YXBwZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzY29wZS4kZXZhbChhdHRyLnRhcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmJpbmQoXCJrZXl1cFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlLiRldmFsKGF0dHJzLm5nRW50ZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRWRpdENvbnRyb2xsZXIsIHN0b3J5UGFyc2VyO1xuXG4gIHN0b3J5UGFyc2VyID0gcmVxdWlyZSgnLi9zdG9yeS1wYXJzZXInKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEVkaXRDb250cm9sbGVyID0gZnVuY3Rpb24oJHNjb3BlLCAkbG9jYXRpb24sICRyb3V0ZVBhcmFtcywgJHRpbWVvdXQpIHtcbiAgICB2YXIgaWQsIGxhc3RJRDtcbiAgICAkKCdpbnB1dC50aXRsZScpLmhpZGUoKTtcbiAgICAkKCcuc3RvcnknKS5oaWRlKCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICQoJ2lucHV0LnRpdGxlJykuc2hvdygpO1xuICAgICAgcmV0dXJuICQoJy5zdG9yeScpLnNob3coKTtcbiAgICB9LCA1MCk7XG4gICAgaWQgPSBwYXJzZUludCgkcm91dGVQYXJhbXMuaWQpO1xuICAgIGlmIChpZCAhPT0gMCkge1xuICAgICAgJHNjb3BlLnN0b3J5ID0gXy5maW5kKCRzY29wZS5zdG9yaWVzLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChzLmlkKSA9PT0gaWQ7XG4gICAgICB9KTtcbiAgICAgIGlmICghJHNjb3BlLnN0b3J5KSB7XG4gICAgICAgIGdvdG8oJ2hvbWUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0SUQgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xhc3RJRCcpO1xuICAgICAgaWYgKGxhc3RJRCA9PSBudWxsKSB7XG4gICAgICAgIGxhc3RJRCA9IDA7XG4gICAgICB9XG4gICAgICAkc2NvcGUuc3RvcnkgPSB7XG4gICAgICAgIGlkOiBwYXJzZUludChsYXN0SUQpICsgMVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJTVE9SWSBJRDogXCIgKyAkc2NvcGUuc3RvcnkuaWQpO1xuICAgICRzY29wZS50aXRsZUVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJCgnLnN0b3J5JykuZm9jdXMoKTtcbiAgICB9O1xuICAgICRzY29wZS50ZXh0RW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAkKCcuc3RvcnknKS5ibHVyKCk7XG4gICAgfTtcbiAgICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCwgcywgdGV4dCwgdGl0bGUsIHRpdGxlYXJyLCB3LCBfaSwgX2osIF9rLCBfbGVuLCBfbGVuMSwgX2xlbjIsIF9yZWYsIF9yZWYxO1xuICAgICAgdGl0bGUgPSAkc2NvcGUuc3RvcnkudGl0bGU7XG4gICAgICBpZiAoIXRpdGxlIHx8IHRpdGxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAkc2NvcGUuZXJyb3IgPSBcIlRpdGxlIGlzIHJlcXVpcmVkXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlYXJyID0gdGl0bGUuc3BsaXQoJyAnKTtcbiAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0aXRsZWFyci5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHcgPSB0aXRsZWFycltfaV07XG4gICAgICAgICAgdGl0bGUgKz0gUyh3KS5jYXBpdGFsaXplKCkucyArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5zdG9yeS5pZCA9IHBhcnNlSW50KCRzY29wZS5zdG9yeS5pZCk7XG4gICAgICAgICRzY29wZS5zdG9yeS50aXRsZSA9IFModGl0bGUpLnRyaW0oKS5zO1xuICAgICAgfVxuICAgICAgdGV4dCA9ICRzY29wZS5zdG9yeS50ZXh0O1xuICAgICAgaWYgKCF0ZXh0IHx8IHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICRzY29wZS5lcnJvciA9IFwiU3RvcnkgaXMgdG9vIHNob3J0IVwiO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBzdG9yeVBhcnNlci5wYXJzZSgkc2NvcGUuc3RvcnkudGV4dCk7XG4gICAgICAkc2NvcGUuc3Rvcnkuc2VudGVuY2VzID0gcmVzdWx0LnNlbnRlbmNlcztcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIF9yZWYgPSByZXN1bHQuc2VudGVuY2VzO1xuICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgcyA9IF9yZWZbX2pdO1xuICAgICAgICBfcmVmMSA9IHMud29yZHM7XG4gICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IF9yZWYxLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgIHcgPSBfcmVmMVtfa107XG4gICAgICAgICAgdGV4dCArPSB3ICsgJyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkc2NvcGUuc3RvcnkudGV4dCA9IHRleHQ7XG4gICAgICBpZiAoaWQgPT09IDApIHtcbiAgICAgICAgJHNjb3BlLnN0b3JpZXMucHVzaCgkc2NvcGUuc3RvcnkpO1xuICAgICAgfVxuICAgICAgJHNjb3BlLmFsbFdvcmRzID0gXy51bmlvbigkc2NvcGUuYWxsV29yZHMsIHJlc3VsdC53b3Jkcyk7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3N0b3JpZXMnLCBKU09OLnN0cmluZ2lmeSgkc2NvcGUuc3RvcmllcykpO1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3b3JkcycsIEpTT04uc3RyaW5naWZ5KCRzY29wZS5hbGxXb3JkcykpO1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdsYXN0SUQnLCAkc2NvcGUuc3RvcnkuaWQpO1xuICAgICAgcmV0dXJuICRsb2NhdGlvbi5wYXRoKFwic3RvcnkvXCIgKyAkc2NvcGUuc3RvcnkuaWQgKyBcIi8xLzFcIik7XG4gICAgfTtcbiAgICAkc2NvcGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBzLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGlkID0gcGFyc2VJbnQoJHJvdXRlUGFyYW1zLmlkKTtcbiAgICAgIGlmIChpZCA9PT0gMCkge1xuICAgICAgICAkc2NvcGUuZ290bygnaG9tZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfcmVmID0gJHNjb3BlLnN0b3JpZXM7XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICBzID0gX3JlZltpXTtcbiAgICAgICAgaWYgKHMuaWQgPT09ICRzY29wZS5zdG9yeS5pZCkge1xuICAgICAgICAgICRzY29wZS5zdG9yaWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3N0b3JpZXMnLCBKU09OLnN0cmluZ2lmeSgkc2NvcGUuc3RvcmllcykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkc2NvcGUuZ290bygnaG9tZScpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9O1xuICAgICRzY29wZS5zZWFyY2hGb3JTdG9yeUltYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJHNjb3BlLmltYWdlU2VhcmNoID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiAkc2NvcGUuY2FwdHVyZVN0b3J5SW1hZ2UgPSBmdW5jdGlvbigpIHt9O1xuICB9O1xuXG4gIEVkaXRDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckbG9jYXRpb24nLCAnJHJvdXRlUGFyYW1zJywgJyR0aW1lb3V0J107XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBTLCBTdG9yeVBhcnNlciwgXztcblxuICBTID0gcmVxdWlyZShcInN0cmluZ1wiKTtcblxuICBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5cbiAgU3RvcnlQYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3RvcnlQYXJzZXIoKSB7fVxuXG4gICAgU3RvcnlQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIG1lc3NhZ2UsIHAsIHB1bmN0dWF0aW9uLCByZXN1bHQsIHNlbnRlbmNlUmVnLCBzdG9yeVJlZywgd29yZCwgd29yZHMsIF9pLCBfbGVuO1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB3b3JkczogW10sXG4gICAgICAgIHNlbnRlbmNlczogW11cbiAgICAgIH07XG4gICAgICBpZiAoIVModGV4dCkuZW5kc1dpdGgoJy4nKSB8fCAhUyh0ZXh0KS5lbmRzV2l0aCgnIScpIHx8ICFTKHRleHQpLmVuZHNXaXRoKCc/JykgfHwgIVModGV4dCkuZW5kc1dpdGgoJy4uLicpKSB7XG4gICAgICAgIHRleHQgKz0gJy4nO1xuICAgICAgfVxuICAgICAgc3RvcnlSZWcgPSAvW1xcc1xcU10qP1tcXC5cXCFcXD9dKFxcLlxcLik/L2dtO1xuICAgICAgcHVuY3R1YXRpb24gPSBbJygnLCAnKScsICcsJywgJy4uLicsICchJywgJz8nLCAnOycsICcuJywgJzonLCAnXCInXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcHVuY3R1YXRpb24ubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcCA9IHB1bmN0dWF0aW9uW19pXTtcbiAgICAgICAgdGV4dCA9IFModGV4dCkucmVwbGFjZUFsbChwLCBcIiBcIiArIHAgKyBcIiBcIik7XG4gICAgICB9XG4gICAgICB3aGlsZSAobWVzc2FnZSA9IHN0b3J5UmVnLmV4ZWModGV4dCkpIHtcbiAgICAgICAgc2VudGVuY2VSZWcgPSAvXFxTKy9nbTtcbiAgICAgICAgd29yZHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHdvcmQgPSBzZW50ZW5jZVJlZy5leGVjKG1lc3NhZ2VbMF0pKSB7XG4gICAgICAgICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgd29yZFswXSA9IFMod29yZFswXSkuY2FwaXRhbGl6ZSgpLnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmRzLnB1c2god29yZFswXSk7XG4gICAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdC53b3Jkcywgd29yZFswXS50b0xvd2VyQ2FzZSgpKSAmJiAhXy5jb250YWlucyhwdW5jdHVhdGlvbiwgd29yZFswXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC53b3Jkcy5wdXNoKHdvcmRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZHMubGVuZ3RoID09PSAxICYmIF8uY29udGFpbnMocHVuY3R1YXRpb24sIHdvcmRzWzBdKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5zZW50ZW5jZXMucHVzaCh7XG4gICAgICAgICAgd29yZHM6IHdvcmRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0b3J5UGFyc2VyO1xuXG4gIH0pKCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXcgU3RvcnlQYXJzZXIoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEZpbGVTZXJ2aWNlLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgRmlsZVNlcnZpY2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRmlsZVNlcnZpY2UoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUgPSBfX2JpbmQodGhpcy5pbml0aWFsaXplLCB0aGlzKTtcbiAgICB9XG5cbiAgICBGaWxlU2VydmljZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY29yZG92YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aW5kb3cucmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTChjb3Jkb3ZhLmZpbGUuZXh0ZXJuYWxEYXRhRGlyZWN0b3J5LCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgIF90aGlzLnJvb3QgPSBmaWxlRW50cnkudG9VUkwoKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgRmlsZVNlcnZpY2UucHJvdG90eXBlLmdldFVSTCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiRmlsZSBzZXJ2aWNlIHdhcyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290ICsgXCIvXCIgKyBmaWxlbmFtZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbGVTZXJ2aWNlO1xuXG4gIH0pKCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXcgRmlsZVNlcnZpY2UoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIHNlcnZpY2UsIHN0b3JhZ2U7XG5cbiAgc2VydmljZSA9IHJlcXVpcmUoJy4vLi4vc3Rvcnktc2VydmljZScpO1xuXG4gIHN0b3JhZ2UgPSByZXF1aXJlKCcuLy4uL3N0b3JhZ2Utc2VydmljZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gW1xuICAgICckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICRzY29wZS5hbGxDYXBzID0gc3RvcmFnZS5sb2FkSW50KCdhbGxDYXBzJyk7XG4gICAgICAkc2NvcGUuc3RvcmllcyA9IHNlcnZpY2UuZ2V0U3RvcmllcygpO1xuICAgICAgJHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuICRzY29wZS5nb3RvKFwic3RvcnkvXCIgKyBzLmlkKTtcbiAgICAgIH07XG4gICAgICAkc2NvcGUucmVtb3ZlID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gc2VydmljZS5yZW1vdmVTdG9yeShzKTtcbiAgICAgIH07XG4gICAgICAkc2NvcGUubmV3U3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRzY29wZS5zZWxlY3Qoc2VydmljZS5uZXdTdG9yeShcIk5ldyBTdG9yeVwiKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuICRzY29wZS50b2dnbGVDYXBzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5jYXBPbiA9ICEkc2NvcGUuY2FwT247XG4gICAgICAgIHJldHVybiBzdG9yYWdlLnNhdmVJbnQoJ2FsbENhcHMnKTtcbiAgICAgIH07XG4gICAgfVxuICBdO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSW5kZXhDb250cm9sbGVyLCBmaWxlU2VydmljZTtcblxuICBmaWxlU2VydmljZSA9IHJlcXVpcmUoJy4vZmlsZS1zZXJ2aWNlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBJbmRleENvbnRyb2xsZXIgPSBmdW5jdGlvbigkc2NvcGUsICRsb2NhdGlvbiwgJGNvcmRvdmFGaWxlKSB7XG4gICAgdmFyIHdvcmRzU3RyaW5nO1xuICAgIGZpbGVTZXJ2aWNlLmluaXRpYWxpemUoKTtcbiAgICAkc2NvcGUuYXBwVGl0bGUgPSBcIlN0b3J5IFJlYWRlclwiO1xuICAgICRzY29wZS5wdW5jdHVhdGlvbiA9IFsnKCcsICcpJywgJywnLCAnLi4uJywgJyEnLCAnPycsICc7JywgJy4nLCAnOicsICdcIiddO1xuICAgICRzY29wZS5sb2cgPSBmdW5jdGlvbih0b0xvZykge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRvTG9nLCBudWxsLCAyKSk7XG4gICAgfTtcbiAgICB3b3Jkc1N0cmluZyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIndvcmRzXCIpO1xuICAgIGlmICh3b3Jkc1N0cmluZyA9PSBudWxsKSB7XG4gICAgICB3b3Jkc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KFtdKTtcbiAgICB9XG4gICAgJHNjb3BlLmFsbFdvcmRzID0gSlNPTi5wYXJzZSh3b3Jkc1N0cmluZyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZHNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRzY29wZS5rZXlib2FyZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkaGlkZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJHNjb3BlLmtleWJvYXJkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAkc2NvcGUuZ290byA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiAkbG9jYXRpb24ucGF0aChwYXRoKTtcbiAgICB9O1xuICAgIHJldHVybiAkc2NvcGUuYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIGlmICh0aGlzLmlzUGhvbmVHYXApIHtcbiAgICBJbmRleENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRsb2NhdGlvbicsICckY29yZG92YUZpbGUnXTtcbiAgfSBlbHNlIHtcbiAgICBJbmRleENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRsb2NhdGlvbiddO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBNZWRpYVNlcnZpY2UsIGZpbGVTZXJ2aWNlLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgZmlsZVNlcnZpY2UgPSByZXF1aXJlKCcuL2ZpbGUtc2VydmljZScpO1xuXG4gIE1lZGlhU2VydmljZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNZWRpYVNlcnZpY2UoKSB7XG4gICAgICB0aGlzLnJlY29yZCA9IF9fYmluZCh0aGlzLnJlY29yZCwgdGhpcyk7XG4gICAgICB0aGlzLnBsYXkgPSBfX2JpbmQodGhpcy5wbGF5LCB0aGlzKTtcbiAgICB9XG5cbiAgICBNZWRpYVNlcnZpY2UucHJvdG90eXBlLmdldFVSTCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBmaWxlU2VydmljZS5nZXRVUkwocGF0aCk7XG4gICAgfTtcblxuICAgIE1lZGlhU2VydmljZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZG9uZSwgdXJsO1xuICAgICAgdXJsID0gZmlsZVNlcnZpY2UuZ2V0VVJMKHBhdGgpO1xuICAgICAgZG9uZSA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuc3RvcCgpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLm1lZGlhID0gbmV3IE1lZGlhKHVybCwgZG9uZSwgZG9uZSk7XG4gICAgICB0aGlzLm1lZGlhLnBsYXkoKTtcbiAgICAgIHJldHVybiB0aGlzLnBsYXlpbmcgPSBwYXRoO1xuICAgIH07XG5cbiAgICBNZWRpYVNlcnZpY2UucHJvdG90eXBlLnJlY29yZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBkb25lLCB1cmw7XG4gICAgICB1cmwgPSBmaWxlU2VydmljZS5nZXRVUkwocGF0aCk7XG4gICAgICBkb25lID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5zdG9wKCk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMubWVkaWEgPSBuZXcgTWVkaWEodXJsLCBkb25lLCBkb25lKTtcbiAgICAgIHRoaXMubWVkaWEuc3RhcnRSZWNvcmQoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlY29yZGluZyA9IHBhdGg7XG4gICAgfTtcblxuICAgIE1lZGlhU2VydmljZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMubGlzdGVuaW5nKSB7XG4gICAgICAgIHRoaXMucmVjb2duaXRpb24uc3RvcCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5pbmc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYS5zdG9wKCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucGxheWluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvcmRpbmcpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhLnN0b3BSZWNvcmQoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5yZWNvcmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWRpYS5yZWxlYXNlKCk7XG4gICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5tZWRpYTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTWVkaWFTZXJ2aWNlLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbihjb250aW51b3VzLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGU7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZWNvZ25pdGlvbiA9IG5ldyBTcGVlY2hSZWNvZ25pdGlvbigpO1xuICAgICAgICB0aGlzLnJlY29nbml0aW9uLmNvbnRpbnVvdXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHRoaXMucmVjb2duaXRpb24ub25yZXN1bHQgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdSZXN1bHQsIHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGV2ZW50LnJlc3VsdHNbMF1bMF0udHJhbnNjcmlwdDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVzdWx0OiBcIiArIHJlc3VsdCk7XG4gICAgICAgICAgICBuZXdSZXN1bHQgPSByZXN1bHQuc3Vic3RyKF90aGlzLmxhc3RSZXN1bHQubGVuZ3RoKTtcbiAgICAgICAgICAgIF90aGlzLmxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3UmVzdWx0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWNvZ25pdGlvbi5vbmVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiZW5kZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVjb2duaXRpb24ub25ub21hdGNoID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJubyBtYXRjaFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb2duaXRpb24uc3RhcnQoKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBNZWRpYVNlcnZpY2U7XG5cbiAgfSkoKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IG5ldyBNZWRpYVNlcnZpY2UoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIFJlY29yZGluZ0NvbnRyb2xsZXI7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBSZWNvcmRpbmdDb250cm9sbGVyID0gZnVuY3Rpb24oJHNjb3BlLCAkbG9jYXRpb24sICR0aW1lb3V0KSB7XG4gICAgJHNjb3BlLnBsYXkgPSBmdW5jdGlvbih3b3JkKSB7XG4gICAgICB2YXIgZmlsZW5hbWU7XG4gICAgICBmaWxlbmFtZSA9ICRzY29wZS5mb2xkZXJQYXRoICsgKFwiL1wiICsgd29yZCArIFwiLm1wM1wiKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiUGxheWluZzogXCIgKyBmaWxlbmFtZSk7XG4gICAgICAkc2NvcGUubWVkaWEgPSBuZXcgTWVkaWEoZmlsZW5hbWUsIGZ1bmN0aW9uKHN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICRzY29wZS5wbGF5aW5nID0gdm9pZCAwO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICAgIHJldHVybiAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAkc2NvcGUucGxheWluZyA9IHZvaWQgMDtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHN0YXR1cykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gJHNjb3BlLm1lZGlhLnBsYXkoKTtcbiAgICB9O1xuICAgICRzY29wZS5yZWNvcmQgPSBmdW5jdGlvbih3b3JkKSB7XG4gICAgICB2YXIgZmlsZW5hbWU7XG4gICAgICBmaWxlbmFtZSA9ICRzY29wZS5mb2xkZXJQYXRoICsgKFwiL1wiICsgd29yZCArIFwiLm1wM1wiKTtcbiAgICAgICRzY29wZS5zdG9wKCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlY29yZGluZzogXCIgKyBmaWxlbmFtZSk7XG4gICAgICAkc2NvcGUucmVjb3JkaW5nID0gd29yZDtcbiAgICAgICRzY29wZS5tZWRpYSA9IG5ldyBNZWRpYShmaWxlbmFtZSwgZnVuY3Rpb24oc3VjY2Vzcykge1xuICAgICAgICByZXR1cm4gJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gJHNjb3BlLnJlY29yZGluZyA9IHZvaWQgMDtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICByZXR1cm4gJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gJHNjb3BlLnJlY29yZGluZyA9IHZvaWQgMDtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHN0YXR1cykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gJHNjb3BlLm1lZGlhLnN0YXJ0UmVjb3JkKCk7XG4gICAgfTtcbiAgICAkc2NvcGVbXCJjb250aW51ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnN0b3AoKTtcbiAgICAgIHJldHVybiAkc2NvcGUuZ290bygnaG9tZScpO1xuICAgIH07XG4gICAgcmV0dXJuICRzY29wZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHNjb3BlLnBsYXlpbmcpIHtcbiAgICAgICAgaWYgKCRzY29wZS5tZWRpYSkge1xuICAgICAgICAgICRzY29wZS5tZWRpYS5zdG9wKCk7XG4gICAgICAgICAgJHNjb3BlLnBsYXlpbmcgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgkc2NvcGUucmVjb3JkaW5nKSB7XG4gICAgICAgIGlmICgkc2NvcGUubWVkaWEpIHtcbiAgICAgICAgICAkc2NvcGUubWVkaWEuc3RvcFJlY29yZCgpO1xuICAgICAgICAgIHJldHVybiAkc2NvcGUucmVjb3JkaW5nID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBSZWNvcmRpbmdDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckbG9jYXRpb24nLCAnJHRpbWVvdXQnXTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIFN0b3JhZ2VTZXJ2aWNlO1xuXG4gIFN0b3JhZ2VTZXJ2aWNlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0b3JhZ2VTZXJ2aWNlKCkge31cblxuICAgIFN0b3JhZ2VTZXJ2aWNlLnByb3RvdHlwZS5yZXNldElEID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2F2ZUludCgnbmV4dElEJywgMCk7XG4gICAgfTtcblxuICAgIFN0b3JhZ2VTZXJ2aWNlLnByb3RvdHlwZS5nZXROZXh0SUQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXh0SUQ7XG4gICAgICBuZXh0SUQgPSB0aGlzLmxvYWRJbnQoJ25leHRJRCcpO1xuICAgICAgdGhpcy5zYXZlSW50KCduZXh0SUQnLCBuZXh0SUQgKyAxKTtcbiAgICAgIHJldHVybiBuZXh0SUQ7XG4gICAgfTtcblxuICAgIFN0b3JhZ2VTZXJ2aWNlLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfTtcblxuICAgIFN0b3JhZ2VTZXJ2aWNlLnByb3RvdHlwZS5zYXZlSW50ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgU3RvcmFnZVNlcnZpY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH07XG5cbiAgICBTdG9yYWdlU2VydmljZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFsdWUgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFN0b3JhZ2VTZXJ2aWNlLnByb3RvdHlwZS5sb2FkQXJyYXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhbHVlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH07XG5cbiAgICBTdG9yYWdlU2VydmljZS5wcm90b3R5cGUubG9hZEludCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFsdWUgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdG9yYWdlU2VydmljZTtcblxuICB9KSgpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gbmV3IFN0b3JhZ2VTZXJ2aWNlKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBTLCBTdG9yeVNlcnZpY2UsIHN0b3JhZ2UsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBzdG9yYWdlID0gcmVxdWlyZSgnLi9zdG9yYWdlLXNlcnZpY2UnKTtcblxuICBTID0gcmVxdWlyZSgnc3RyaW5nJyk7XG5cbiAgU3RvcnlTZXJ2aWNlID0gKGZ1bmN0aW9uKCkge1xuICAgIFN0b3J5U2VydmljZS5wcm90b3R5cGUucHVuY3R1YXRpb24gPSBbJygnLCAnKScsICcsJywgJy4uLicsICchJywgJz8nLCAnOycsICcuJywgJzonLCAnXCInXTtcblxuICAgIGZ1bmN0aW9uIFN0b3J5U2VydmljZSgpIHtcbiAgICAgIHRoaXMuc2F2ZVBhZ2UgPSBfX2JpbmQodGhpcy5zYXZlUGFnZSwgdGhpcyk7XG4gICAgICB0aGlzLnJlbW92ZVBhZ2UgPSBfX2JpbmQodGhpcy5yZW1vdmVQYWdlLCB0aGlzKTtcbiAgICAgIHRoaXMuYWRkUGFnZSA9IF9fYmluZCh0aGlzLmFkZFBhZ2UsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRQYWdlcyA9IF9fYmluZCh0aGlzLmdldFBhZ2VzLCB0aGlzKTtcbiAgICAgIHRoaXMuc2VsZWN0U3RvcnkgPSBfX2JpbmQodGhpcy5zZWxlY3RTdG9yeSwgdGhpcyk7XG4gICAgICB0aGlzLnJlbW92ZVN0b3J5ID0gX19iaW5kKHRoaXMucmVtb3ZlU3RvcnksIHRoaXMpO1xuICAgICAgdGhpcy5uZXdTdG9yeSA9IF9fYmluZCh0aGlzLm5ld1N0b3J5LCB0aGlzKTtcbiAgICAgIHRoaXMucmVzZXRTdG9yaWVzID0gX19iaW5kKHRoaXMucmVzZXRTdG9yaWVzLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0U3RvcmllcyA9IF9fYmluZCh0aGlzLmdldFN0b3JpZXMsIHRoaXMpO1xuICAgICAgdGhpcy5zdG9yaWVzID0gc3RvcmFnZS5sb2FkQXJyYXkoJ3N0b3JpZXMnKTtcbiAgICB9XG5cbiAgICBTdG9yeVNlcnZpY2UucHJvdG90eXBlLmdldFN0b3JpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JpZXM7XG4gICAgfTtcblxuICAgIFN0b3J5U2VydmljZS5wcm90b3R5cGUucmVzZXRTdG9yaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0b3JpZXMgPSBbXTtcbiAgICAgIHJldHVybiBzdG9yYWdlLnNhdmUodGhpcy5zdG9yaWVzKTtcbiAgICB9O1xuXG4gICAgU3RvcnlTZXJ2aWNlLnByb3RvdHlwZS5uZXdTdG9yeSA9IGZ1bmN0aW9uKHRpdGxlLCBpbWFnZVVSTCkge1xuICAgICAgdmFyIHN0b3J5O1xuICAgICAgc3RvcnkgPSB7XG4gICAgICAgIGlkOiBzdG9yYWdlLmdldE5leHRJRCgpLFxuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGltYWdlVVJMOiBpbWFnZVVSTFxuICAgICAgfTtcbiAgICAgIHRoaXMuc3Rvcmllcy5wdXNoKHN0b3J5KTtcbiAgICAgIHN0b3JhZ2Uuc2F2ZSgnc3RvcmllcycsIHRoaXMuc3Rvcmllcyk7XG4gICAgICB0aGlzLnNlbGVjdFN0b3J5KHN0b3J5LmlkKTtcbiAgICAgIHRoaXMuYWRkUGFnZSh0aXRsZSwgaW1hZ2VVUkwpO1xuICAgICAgcmV0dXJuIHN0b3J5O1xuICAgIH07XG5cbiAgICBTdG9yeVNlcnZpY2UucHJvdG90eXBlLnJlbW92ZVN0b3J5ID0gZnVuY3Rpb24oc3RvcnkpIHtcbiAgICAgIF8ucmVtb3ZlKHRoaXMuc3RvcmllcywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5pZCA9PT0gc3RvcnkuaWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdG9yYWdlLnNhdmUoJ3N0b3JpZXMnLCB0aGlzLnN0b3JpZXMpO1xuICAgIH07XG5cbiAgICBTdG9yeVNlcnZpY2UucHJvdG90eXBlLnNlbGVjdFN0b3J5ID0gZnVuY3Rpb24oc3RvcnlJRCkge1xuICAgICAgdGhpcy5wYWdlc0tleSA9IFwic3RvcnktcGFnZXMtXCIgKyBzdG9yeUlEO1xuICAgICAgdGhpcy5wYWdlcyA9IHN0b3JhZ2UubG9hZEFycmF5KHRoaXMucGFnZXNLZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcnkgPSBfLmZpbmQodGhpcy5zdG9yaWVzLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzLmlkID09PSBzdG9yeUlEO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFN0b3J5U2VydmljZS5wcm90b3R5cGUuZ2V0UGFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhZ2VzO1xuICAgIH07XG5cbiAgICBTdG9yeVNlcnZpY2UucHJvdG90eXBlLmFkZFBhZ2UgPSBmdW5jdGlvbih0ZXh0LCBpbWFnZVVSTCkge1xuICAgICAgdmFyIHBhZ2U7XG4gICAgICBpZiAodGhpcy5zdG9yeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2Fubm90IGFkZCBwYWdlLiBTdG9yeSBub3Qgc2VsZWN0ZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhZ2UgPSB7XG4gICAgICAgIGlkOiBzdG9yYWdlLmdldE5leHRJRCgpLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpbWFnZVVSTDogaW1hZ2VVUkxcbiAgICAgIH07XG4gICAgICB0aGlzLnBhZ2VzLnB1c2gocGFnZSk7XG4gICAgICByZXR1cm4gdGhpcy5zYXZlUGFnZShwYWdlKTtcbiAgICB9O1xuXG4gICAgU3RvcnlTZXJ2aWNlLnByb3RvdHlwZS5yZW1vdmVQYWdlID0gZnVuY3Rpb24ocGFnZUlEKSB7XG4gICAgICBpZiAocGFnZUlEID09PSB0aGlzLnBhZ2VzWzBdLmlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF8ucmVtb3ZlKHRoaXMucGFnZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHAuaWQgPT09IHBhZ2VJRDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0b3JhZ2Uuc2F2ZSh0aGlzLnBhZ2VzS2V5LCB0aGlzLnBhZ2VzKTtcbiAgICB9O1xuXG4gICAgU3RvcnlTZXJ2aWNlLnByb3RvdHlwZS5zYXZlUGFnZSA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgICAgIHZhciBwLCB0ZXh0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIF9yZWYgPSB0aGlzLnB1bmN0dWF0aW9uO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHAgPSBfcmVmW19pXTtcbiAgICAgICAgdGV4dCA9IFMocGFnZS50ZXh0KS5yZXBsYWNlQWxsKHAsIFwiIFwiICsgcCArIFwiIFwiKS5zO1xuICAgICAgfVxuICAgICAgcGFnZS50ZXh0ID0gUyh0ZXh0KS5jb2xsYXBzZVdoaXRlc3BhY2UoKS5zO1xuICAgICAgcGFnZS53b3JkcyA9IHRleHQuc3BsaXQoXCIgXCIpO1xuICAgICAgc3RvcmFnZS5zYXZlKHRoaXMucGFnZXNLZXksIHRoaXMucGFnZXMpO1xuICAgICAgaWYgKHRoaXMucGFnZXNbMF0uaWQgPT09IHBhZ2UuaWQpIHtcbiAgICAgICAgdGhpcy5zdG9yeS50aXRsZSA9IHBhZ2UudGV4dDtcbiAgICAgICAgdGhpcy5zdG9yeS5pbWFnZVVSTCA9IHBhZ2UuaW1hZ2VVUkw7XG4gICAgICAgIHJldHVybiBzdG9yYWdlLnNhdmUoJ3N0b3JpZXMnLCB0aGlzLnN0b3JpZXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU3RvcnlTZXJ2aWNlO1xuXG4gIH0pKCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXcgU3RvcnlTZXJ2aWNlKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBTdG9yeUNvbnRyb2xsZXIsIG1lZGlhU2VydmljZSwgc2VydmljZXMsIHN0b3J5U2VydmljZTtcblxuICBzdG9yeVNlcnZpY2UgPSByZXF1aXJlKCcuLy4uL3N0b3J5LXNlcnZpY2UnKTtcblxuICBtZWRpYVNlcnZpY2UgPSByZXF1aXJlKCcuLy4uL21lZGlhLXNlcnZpY2UnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFN0b3J5Q29udHJvbGxlciA9IGZ1bmN0aW9uKCRzY29wZSwgJGxvY2F0aW9uLCAkcm91dGVQYXJhbXMsICR0aW1lb3V0LCAkaHR0cCwgJGNvcmRvdmFGaWxlLCAkY29yZG92YUZpbGVUcmFuc2ZlciwgJGNvcmRvdmFDYW1lcmEpIHtcbiAgICBjb25zb2xlLmxvZyhcIlN0b3J5IElEOiBcIiArICRyb3V0ZVBhcmFtcy5pZCk7XG4gICAgc3RvcnlTZXJ2aWNlLnNlbGVjdFN0b3J5KHBhcnNlSW50KCRyb3V0ZVBhcmFtcy5pZCkpO1xuICAgICRzY29wZS5wYWdlcyA9IHN0b3J5U2VydmljZS5nZXRQYWdlcygpO1xuICAgICRzY29wZS5wYWdlSW5kZXggPSAwO1xuICAgICRzY29wZS5wYWdlID0gJHNjb3BlLnBhZ2VzWzBdO1xuICAgICRzY29wZS5tb2RlID0gJ3JlYWQnO1xuICAgICRzY29wZS5pc1N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJHNjb3BlLnBhZ2VJbmRleCA9PT0gMDtcbiAgICB9O1xuICAgICRzY29wZS5pc0VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICRzY29wZS5wYWdlSW5kZXggKyAxID49ICRzY29wZS5wYWdlcy5sZW5ndGg7XG4gICAgfTtcbiAgICAkc2NvcGUuc3RvcE1lZGlhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWVkaWFTZXJ2aWNlLnN0b3AoKTtcbiAgICB9O1xuICAgICRzY29wZS5uZXh0UGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgbWVkaWFTZXJ2aWNlLnN0b3AoKTtcbiAgICAgIGlmICghdGhpcy5pc0VuZCgpKSB7XG4gICAgICAgICRzY29wZS5wYWdlSW5kZXgrKztcbiAgICAgICAgcmV0dXJuICRzY29wZS5wYWdlID0gJHNjb3BlLnBhZ2VzWyRzY29wZS5wYWdlSW5kZXhdO1xuICAgICAgfVxuICAgIH07XG4gICAgJHNjb3BlLnByZXZQYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBtZWRpYVNlcnZpY2Uuc3RvcCgpO1xuICAgICAgaWYgKCF0aGlzLmlzU3RhcnQoKSkge1xuICAgICAgICAkc2NvcGUucGFnZUluZGV4LS07XG4gICAgICAgIHJldHVybiAkc2NvcGUucGFnZSA9ICRzY29wZS5wYWdlc1skc2NvcGUucGFnZUluZGV4XTtcbiAgICAgIH1cbiAgICB9O1xuICAgICRzY29wZS5ob21lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJHNjb3BlLmdvdG8oJycpO1xuICAgIH07XG4gICAgJHNjb3BlLnRvZ2dsZU9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIG1lZGlhU2VydmljZS5zdG9wKCk7XG4gICAgICByZXR1cm4gJHNjb3BlLm9wdGlvbnMgPSAhJHNjb3BlLm9wdGlvbnM7XG4gICAgfTtcbiAgICAkc2NvcGUudG9nZ2xlRWRpdFBhZ2VUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudGV4dEVkaXQgPSAhJHNjb3BlLnRleHRFZGl0O1xuICAgICAgaWYgKCRzY29wZS50ZXh0RWRpdCkge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gJCgnI3BhZ2V0ZXh0JykuZm9jdXMoKTtcbiAgICAgICAgfSwgNTApO1xuICAgICAgfVxuICAgIH07XG4gICAgJHNjb3BlLnRvZ2dsZUVkaXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHNjb3BlLm1vZGUgPT09ICdlZGl0Jykge1xuICAgICAgICByZXR1cm4gJHNjb3BlLm1vZGUgPSAncmVhZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJHNjb3BlLm1vZGUgPSAnZWRpdCc7XG4gICAgICB9XG4gICAgfTtcbiAgICAkc2NvcGUuZGVsZXRlUGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCRzY29wZS5wYWdlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcnlTZXJ2aWNlLnJlbW92ZVBhZ2UoJHNjb3BlLnBhZ2UuaWQpO1xuICAgICAgJHNjb3BlLmNvbmZpcm1EZWxldGVQYWdlID0gZmFsc2U7XG4gICAgICBpZiAoJHNjb3BlLnBhZ2VJbmRleCA+PSAkc2NvcGUucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICRzY29wZS5wYWdlSW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkc2NvcGUucGFnZSA9ICRzY29wZS5wYWdlc1skc2NvcGUucGFnZUluZGV4XTtcbiAgICB9O1xuICAgICRzY29wZS5hZGRQYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFnZU51bWJlcjtcbiAgICAgIHBhZ2VOdW1iZXIgPSAkc2NvcGUucGFnZXMubGVuZ3RoICsgMTtcbiAgICAgIHN0b3J5U2VydmljZS5hZGRQYWdlKFwiUGFnZSBcIiArIHBhZ2VOdW1iZXIpO1xuICAgICAgJHNjb3BlLm5leHRQYWdlKCk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICQoJyNwYWdldGV4dCcpLmZvY3VzKCk7XG4gICAgICB9LCA1MCk7XG4gICAgfTtcbiAgICAkc2NvcGUuc2F2ZVBhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHN0b3J5U2VydmljZS5zYXZlUGFnZSgkc2NvcGUucGFnZSk7XG4gICAgICBjb25zb2xlLmxvZyhcIlBhZ2Ugc2F2ZWRcIik7XG4gICAgICByZXR1cm4gJHNjb3BlLnRleHRFZGl0ID0gZmFsc2U7XG4gICAgfTtcbiAgICAkc2NvcGUuZ29vZ2xlSW1hZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAkc2NvcGUuaW1hZ2VTZWFyY2ggPSB0cnVlO1xuICAgIH07XG4gICAgJHNjb3BlLnNlbGVjdEltYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJHNjb3BlLmltYWdlU2VhcmNoID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gJHNjb3BlLnJlYWQgPSBmdW5jdGlvbih3b3JkKSB7XG4gICAgICBtZWRpYVNlcnZpY2Uuc3RvcCgpO1xuICAgICAgaWYgKHdvcmQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkaW5nID09PSB3b3JkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGUgcmVhZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVhZGluZyA9IHdvcmQ7XG4gICAgICAgIHJldHVybiBtZWRpYVNlcnZpY2UucGxheSh0aGlzLndvcmQucmVjb3JkaW5nUGF0aCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlICRzY29wZS53b3JkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHNlcnZpY2VzID0gWyckc2NvcGUnLCAnJGxvY2F0aW9uJywgJyRyb3V0ZVBhcmFtcycsICckdGltZW91dCcsICckaHR0cCddO1xuXG4gIGlmICh0aGlzLmlzUGhvbmVHYXApIHtcbiAgICBzZXJ2aWNlcy5wdXNoKCckY29yZG92YUZpbGUnKTtcbiAgICBzZXJ2aWNlcy5wdXNoKCckY29yZG92YUZpbGVUcmFuc2ZlcicpO1xuICAgIHNlcnZpY2VzLnB1c2goJyRjb3Jkb3ZhQ2FtZXJhJyk7XG4gIH1cblxuICBTdG9yeUNvbnRyb2xsZXIuJGluamVjdCA9IHNlcnZpY2VzO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiZnVuY3Rpb24gY291bnQoc2VsZiwgc3Vic3RyKSB7XG4gIHZhciBjb3VudCA9IDBcbiAgdmFyIHBvcyA9IHNlbGYuaW5kZXhPZihzdWJzdHIpXG5cbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgY291bnQgKz0gMVxuICAgIHBvcyA9IHNlbGYuaW5kZXhPZihzdWJzdHIsIHBvcyArIDEpXG4gIH1cblxuICByZXR1cm4gY291bnRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3VudCIsIi8qXG5zdHJpbmcuanMgLSBDb3B5cmlnaHQgKEMpIDIwMTItMjAxNCwgSlAgUmljaGFyZHNvbiA8anByaWNoYXJkc29uQGdtYWlsLmNvbT5cbiovXG5cbiEoZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBWRVJTSU9OID0gJzMuMS4xJztcblxuICB2YXIgRU5USVRJRVMgPSB7fTtcblxuICAvLyBmcm9tIGh0dHA6Ly9zZW1wbGljZXdlYnNpdGVzLmNvbS9yZW1vdmluZy1hY2NlbnRzLWphdmFzY3JpcHRcbiAgdmFyIGxhdGluX21hcD17XCLDgVwiOlwiQVwiLFwixIJcIjpcIkFcIixcIuG6rlwiOlwiQVwiLFwi4bq2XCI6XCJBXCIsXCLhurBcIjpcIkFcIixcIuG6slwiOlwiQVwiLFwi4bq0XCI6XCJBXCIsXCLHjVwiOlwiQVwiLFwiw4JcIjpcIkFcIixcIuG6pFwiOlwiQVwiLFwi4bqsXCI6XCJBXCIsXCLhuqZcIjpcIkFcIixcIuG6qFwiOlwiQVwiLFwi4bqqXCI6XCJBXCIsXCLDhFwiOlwiQVwiLFwix55cIjpcIkFcIixcIsimXCI6XCJBXCIsXCLHoFwiOlwiQVwiLFwi4bqgXCI6XCJBXCIsXCLIgFwiOlwiQVwiLFwiw4BcIjpcIkFcIixcIuG6olwiOlwiQVwiLFwiyIJcIjpcIkFcIixcIsSAXCI6XCJBXCIsXCLEhFwiOlwiQVwiLFwiw4VcIjpcIkFcIixcIse6XCI6XCJBXCIsXCLhuIBcIjpcIkFcIixcIsi6XCI6XCJBXCIsXCLDg1wiOlwiQVwiLFwi6pyyXCI6XCJBQVwiLFwiw4ZcIjpcIkFFXCIsXCLHvFwiOlwiQUVcIixcIseiXCI6XCJBRVwiLFwi6py0XCI6XCJBT1wiLFwi6py2XCI6XCJBVVwiLFwi6py4XCI6XCJBVlwiLFwi6py6XCI6XCJBVlwiLFwi6py8XCI6XCJBWVwiLFwi4biCXCI6XCJCXCIsXCLhuIRcIjpcIkJcIixcIsaBXCI6XCJCXCIsXCLhuIZcIjpcIkJcIixcIsmDXCI6XCJCXCIsXCLGglwiOlwiQlwiLFwixIZcIjpcIkNcIixcIsSMXCI6XCJDXCIsXCLDh1wiOlwiQ1wiLFwi4biIXCI6XCJDXCIsXCLEiFwiOlwiQ1wiLFwixIpcIjpcIkNcIixcIsaHXCI6XCJDXCIsXCLIu1wiOlwiQ1wiLFwixI5cIjpcIkRcIixcIuG4kFwiOlwiRFwiLFwi4biSXCI6XCJEXCIsXCLhuIpcIjpcIkRcIixcIuG4jFwiOlwiRFwiLFwixopcIjpcIkRcIixcIuG4jlwiOlwiRFwiLFwix7JcIjpcIkRcIixcIseFXCI6XCJEXCIsXCLEkFwiOlwiRFwiLFwixotcIjpcIkRcIixcIsexXCI6XCJEWlwiLFwix4RcIjpcIkRaXCIsXCLDiVwiOlwiRVwiLFwixJRcIjpcIkVcIixcIsSaXCI6XCJFXCIsXCLIqFwiOlwiRVwiLFwi4bicXCI6XCJFXCIsXCLDilwiOlwiRVwiLFwi4bq+XCI6XCJFXCIsXCLhu4ZcIjpcIkVcIixcIuG7gFwiOlwiRVwiLFwi4buCXCI6XCJFXCIsXCLhu4RcIjpcIkVcIixcIuG4mFwiOlwiRVwiLFwiw4tcIjpcIkVcIixcIsSWXCI6XCJFXCIsXCLhurhcIjpcIkVcIixcIsiEXCI6XCJFXCIsXCLDiFwiOlwiRVwiLFwi4bq6XCI6XCJFXCIsXCLIhlwiOlwiRVwiLFwixJJcIjpcIkVcIixcIuG4llwiOlwiRVwiLFwi4biUXCI6XCJFXCIsXCLEmFwiOlwiRVwiLFwiyYZcIjpcIkVcIixcIuG6vFwiOlwiRVwiLFwi4biaXCI6XCJFXCIsXCLqnapcIjpcIkVUXCIsXCLhuJ5cIjpcIkZcIixcIsaRXCI6XCJGXCIsXCLHtFwiOlwiR1wiLFwixJ5cIjpcIkdcIixcIsemXCI6XCJHXCIsXCLEolwiOlwiR1wiLFwixJxcIjpcIkdcIixcIsSgXCI6XCJHXCIsXCLGk1wiOlwiR1wiLFwi4bigXCI6XCJHXCIsXCLHpFwiOlwiR1wiLFwi4biqXCI6XCJIXCIsXCLInlwiOlwiSFwiLFwi4bioXCI6XCJIXCIsXCLEpFwiOlwiSFwiLFwi4rGnXCI6XCJIXCIsXCLhuKZcIjpcIkhcIixcIuG4olwiOlwiSFwiLFwi4bikXCI6XCJIXCIsXCLEplwiOlwiSFwiLFwiw41cIjpcIklcIixcIsSsXCI6XCJJXCIsXCLHj1wiOlwiSVwiLFwiw45cIjpcIklcIixcIsOPXCI6XCJJXCIsXCLhuK5cIjpcIklcIixcIsSwXCI6XCJJXCIsXCLhu4pcIjpcIklcIixcIsiIXCI6XCJJXCIsXCLDjFwiOlwiSVwiLFwi4buIXCI6XCJJXCIsXCLIilwiOlwiSVwiLFwixKpcIjpcIklcIixcIsSuXCI6XCJJXCIsXCLGl1wiOlwiSVwiLFwixKhcIjpcIklcIixcIuG4rFwiOlwiSVwiLFwi6p25XCI6XCJEXCIsXCLqnbtcIjpcIkZcIixcIuqdvVwiOlwiR1wiLFwi6p6CXCI6XCJSXCIsXCLqnoRcIjpcIlNcIixcIuqehlwiOlwiVFwiLFwi6p2sXCI6XCJJU1wiLFwixLRcIjpcIkpcIixcIsmIXCI6XCJKXCIsXCLhuLBcIjpcIktcIixcIseoXCI6XCJLXCIsXCLEtlwiOlwiS1wiLFwi4rGpXCI6XCJLXCIsXCLqnYJcIjpcIktcIixcIuG4slwiOlwiS1wiLFwixphcIjpcIktcIixcIuG4tFwiOlwiS1wiLFwi6p2AXCI6XCJLXCIsXCLqnYRcIjpcIktcIixcIsS5XCI6XCJMXCIsXCLIvVwiOlwiTFwiLFwixL1cIjpcIkxcIixcIsS7XCI6XCJMXCIsXCLhuLxcIjpcIkxcIixcIuG4tlwiOlwiTFwiLFwi4bi4XCI6XCJMXCIsXCLisaBcIjpcIkxcIixcIuqdiFwiOlwiTFwiLFwi4bi6XCI6XCJMXCIsXCLEv1wiOlwiTFwiLFwi4rGiXCI6XCJMXCIsXCLHiFwiOlwiTFwiLFwixYFcIjpcIkxcIixcIseHXCI6XCJMSlwiLFwi4bi+XCI6XCJNXCIsXCLhuYBcIjpcIk1cIixcIuG5glwiOlwiTVwiLFwi4rGuXCI6XCJNXCIsXCLFg1wiOlwiTlwiLFwixYdcIjpcIk5cIixcIsWFXCI6XCJOXCIsXCLhuYpcIjpcIk5cIixcIuG5hFwiOlwiTlwiLFwi4bmGXCI6XCJOXCIsXCLHuFwiOlwiTlwiLFwixp1cIjpcIk5cIixcIuG5iFwiOlwiTlwiLFwiyKBcIjpcIk5cIixcIseLXCI6XCJOXCIsXCLDkVwiOlwiTlwiLFwix4pcIjpcIk5KXCIsXCLDk1wiOlwiT1wiLFwixY5cIjpcIk9cIixcIseRXCI6XCJPXCIsXCLDlFwiOlwiT1wiLFwi4buQXCI6XCJPXCIsXCLhu5hcIjpcIk9cIixcIuG7klwiOlwiT1wiLFwi4buUXCI6XCJPXCIsXCLhu5ZcIjpcIk9cIixcIsOWXCI6XCJPXCIsXCLIqlwiOlwiT1wiLFwiyK5cIjpcIk9cIixcIsiwXCI6XCJPXCIsXCLhu4xcIjpcIk9cIixcIsWQXCI6XCJPXCIsXCLIjFwiOlwiT1wiLFwiw5JcIjpcIk9cIixcIuG7jlwiOlwiT1wiLFwixqBcIjpcIk9cIixcIuG7mlwiOlwiT1wiLFwi4buiXCI6XCJPXCIsXCLhu5xcIjpcIk9cIixcIuG7nlwiOlwiT1wiLFwi4bugXCI6XCJPXCIsXCLIjlwiOlwiT1wiLFwi6p2KXCI6XCJPXCIsXCLqnYxcIjpcIk9cIixcIsWMXCI6XCJPXCIsXCLhuZJcIjpcIk9cIixcIuG5kFwiOlwiT1wiLFwixp9cIjpcIk9cIixcIseqXCI6XCJPXCIsXCLHrFwiOlwiT1wiLFwiw5hcIjpcIk9cIixcIse+XCI6XCJPXCIsXCLDlVwiOlwiT1wiLFwi4bmMXCI6XCJPXCIsXCLhuY5cIjpcIk9cIixcIsisXCI6XCJPXCIsXCLGolwiOlwiT0lcIixcIuqdjlwiOlwiT09cIixcIsaQXCI6XCJFXCIsXCLGhlwiOlwiT1wiLFwiyKJcIjpcIk9VXCIsXCLhuZRcIjpcIlBcIixcIuG5llwiOlwiUFwiLFwi6p2SXCI6XCJQXCIsXCLGpFwiOlwiUFwiLFwi6p2UXCI6XCJQXCIsXCLisaNcIjpcIlBcIixcIuqdkFwiOlwiUFwiLFwi6p2YXCI6XCJRXCIsXCLqnZZcIjpcIlFcIixcIsWUXCI6XCJSXCIsXCLFmFwiOlwiUlwiLFwixZZcIjpcIlJcIixcIuG5mFwiOlwiUlwiLFwi4bmaXCI6XCJSXCIsXCLhuZxcIjpcIlJcIixcIsiQXCI6XCJSXCIsXCLIklwiOlwiUlwiLFwi4bmeXCI6XCJSXCIsXCLJjFwiOlwiUlwiLFwi4rGkXCI6XCJSXCIsXCLqnL5cIjpcIkNcIixcIsaOXCI6XCJFXCIsXCLFmlwiOlwiU1wiLFwi4bmkXCI6XCJTXCIsXCLFoFwiOlwiU1wiLFwi4bmmXCI6XCJTXCIsXCLFnlwiOlwiU1wiLFwixZxcIjpcIlNcIixcIsiYXCI6XCJTXCIsXCLhuaBcIjpcIlNcIixcIuG5olwiOlwiU1wiLFwi4bmoXCI6XCJTXCIsXCLhup5cIjpcIlNTXCIsXCLFpFwiOlwiVFwiLFwixaJcIjpcIlRcIixcIuG5sFwiOlwiVFwiLFwiyJpcIjpcIlRcIixcIsi+XCI6XCJUXCIsXCLhuapcIjpcIlRcIixcIuG5rFwiOlwiVFwiLFwixqxcIjpcIlRcIixcIuG5rlwiOlwiVFwiLFwixq5cIjpcIlRcIixcIsWmXCI6XCJUXCIsXCLisa9cIjpcIkFcIixcIuqegFwiOlwiTFwiLFwixpxcIjpcIk1cIixcIsmFXCI6XCJWXCIsXCLqnKhcIjpcIlRaXCIsXCLDmlwiOlwiVVwiLFwixaxcIjpcIlVcIixcIseTXCI6XCJVXCIsXCLDm1wiOlwiVVwiLFwi4bm2XCI6XCJVXCIsXCLDnFwiOlwiVVwiLFwix5dcIjpcIlVcIixcIseZXCI6XCJVXCIsXCLHm1wiOlwiVVwiLFwix5VcIjpcIlVcIixcIuG5slwiOlwiVVwiLFwi4bukXCI6XCJVXCIsXCLFsFwiOlwiVVwiLFwiyJRcIjpcIlVcIixcIsOZXCI6XCJVXCIsXCLhu6ZcIjpcIlVcIixcIsavXCI6XCJVXCIsXCLhu6hcIjpcIlVcIixcIuG7sFwiOlwiVVwiLFwi4buqXCI6XCJVXCIsXCLhu6xcIjpcIlVcIixcIuG7rlwiOlwiVVwiLFwiyJZcIjpcIlVcIixcIsWqXCI6XCJVXCIsXCLhubpcIjpcIlVcIixcIsWyXCI6XCJVXCIsXCLFrlwiOlwiVVwiLFwixahcIjpcIlVcIixcIuG5uFwiOlwiVVwiLFwi4bm0XCI6XCJVXCIsXCLqnZ5cIjpcIlZcIixcIuG5vlwiOlwiVlwiLFwixrJcIjpcIlZcIixcIuG5vFwiOlwiVlwiLFwi6p2gXCI6XCJWWVwiLFwi4bqCXCI6XCJXXCIsXCLFtFwiOlwiV1wiLFwi4bqEXCI6XCJXXCIsXCLhuoZcIjpcIldcIixcIuG6iFwiOlwiV1wiLFwi4bqAXCI6XCJXXCIsXCLisbJcIjpcIldcIixcIuG6jFwiOlwiWFwiLFwi4bqKXCI6XCJYXCIsXCLDnVwiOlwiWVwiLFwixbZcIjpcIllcIixcIsW4XCI6XCJZXCIsXCLhuo5cIjpcIllcIixcIuG7tFwiOlwiWVwiLFwi4buyXCI6XCJZXCIsXCLGs1wiOlwiWVwiLFwi4bu2XCI6XCJZXCIsXCLhu75cIjpcIllcIixcIsiyXCI6XCJZXCIsXCLJjlwiOlwiWVwiLFwi4bu4XCI6XCJZXCIsXCLFuVwiOlwiWlwiLFwixb1cIjpcIlpcIixcIuG6kFwiOlwiWlwiLFwi4rGrXCI6XCJaXCIsXCLFu1wiOlwiWlwiLFwi4bqSXCI6XCJaXCIsXCLIpFwiOlwiWlwiLFwi4bqUXCI6XCJaXCIsXCLGtVwiOlwiWlwiLFwixLJcIjpcIklKXCIsXCLFklwiOlwiT0VcIixcIuG0gFwiOlwiQVwiLFwi4bSBXCI6XCJBRVwiLFwiyplcIjpcIkJcIixcIuG0g1wiOlwiQlwiLFwi4bSEXCI6XCJDXCIsXCLhtIVcIjpcIkRcIixcIuG0h1wiOlwiRVwiLFwi6pywXCI6XCJGXCIsXCLJolwiOlwiR1wiLFwiyptcIjpcIkdcIixcIsqcXCI6XCJIXCIsXCLJqlwiOlwiSVwiLFwiyoFcIjpcIlJcIixcIuG0ilwiOlwiSlwiLFwi4bSLXCI6XCJLXCIsXCLKn1wiOlwiTFwiLFwi4bSMXCI6XCJMXCIsXCLhtI1cIjpcIk1cIixcIsm0XCI6XCJOXCIsXCLhtI9cIjpcIk9cIixcIsm2XCI6XCJPRVwiLFwi4bSQXCI6XCJPXCIsXCLhtJVcIjpcIk9VXCIsXCLhtJhcIjpcIlBcIixcIsqAXCI6XCJSXCIsXCLhtI5cIjpcIk5cIixcIuG0mVwiOlwiUlwiLFwi6pyxXCI6XCJTXCIsXCLhtJtcIjpcIlRcIixcIuKxu1wiOlwiRVwiLFwi4bSaXCI6XCJSXCIsXCLhtJxcIjpcIlVcIixcIuG0oFwiOlwiVlwiLFwi4bShXCI6XCJXXCIsXCLKj1wiOlwiWVwiLFwi4bSiXCI6XCJaXCIsXCLDoVwiOlwiYVwiLFwixINcIjpcImFcIixcIuG6r1wiOlwiYVwiLFwi4bq3XCI6XCJhXCIsXCLhurFcIjpcImFcIixcIuG6s1wiOlwiYVwiLFwi4bq1XCI6XCJhXCIsXCLHjlwiOlwiYVwiLFwiw6JcIjpcImFcIixcIuG6pVwiOlwiYVwiLFwi4bqtXCI6XCJhXCIsXCLhuqdcIjpcImFcIixcIuG6qVwiOlwiYVwiLFwi4bqrXCI6XCJhXCIsXCLDpFwiOlwiYVwiLFwix59cIjpcImFcIixcIsinXCI6XCJhXCIsXCLHoVwiOlwiYVwiLFwi4bqhXCI6XCJhXCIsXCLIgVwiOlwiYVwiLFwiw6BcIjpcImFcIixcIuG6o1wiOlwiYVwiLFwiyINcIjpcImFcIixcIsSBXCI6XCJhXCIsXCLEhVwiOlwiYVwiLFwi4baPXCI6XCJhXCIsXCLhuppcIjpcImFcIixcIsOlXCI6XCJhXCIsXCLHu1wiOlwiYVwiLFwi4biBXCI6XCJhXCIsXCLisaVcIjpcImFcIixcIsOjXCI6XCJhXCIsXCLqnLNcIjpcImFhXCIsXCLDplwiOlwiYWVcIixcIse9XCI6XCJhZVwiLFwix6NcIjpcImFlXCIsXCLqnLVcIjpcImFvXCIsXCLqnLdcIjpcImF1XCIsXCLqnLlcIjpcImF2XCIsXCLqnLtcIjpcImF2XCIsXCLqnL1cIjpcImF5XCIsXCLhuINcIjpcImJcIixcIuG4hVwiOlwiYlwiLFwiyZNcIjpcImJcIixcIuG4h1wiOlwiYlwiLFwi4bWsXCI6XCJiXCIsXCLhtoBcIjpcImJcIixcIsaAXCI6XCJiXCIsXCLGg1wiOlwiYlwiLFwiybVcIjpcIm9cIixcIsSHXCI6XCJjXCIsXCLEjVwiOlwiY1wiLFwiw6dcIjpcImNcIixcIuG4iVwiOlwiY1wiLFwixIlcIjpcImNcIixcIsmVXCI6XCJjXCIsXCLEi1wiOlwiY1wiLFwixohcIjpcImNcIixcIsi8XCI6XCJjXCIsXCLEj1wiOlwiZFwiLFwi4biRXCI6XCJkXCIsXCLhuJNcIjpcImRcIixcIsihXCI6XCJkXCIsXCLhuItcIjpcImRcIixcIuG4jVwiOlwiZFwiLFwiyZdcIjpcImRcIixcIuG2kVwiOlwiZFwiLFwi4biPXCI6XCJkXCIsXCLhta1cIjpcImRcIixcIuG2gVwiOlwiZFwiLFwixJFcIjpcImRcIixcIsmWXCI6XCJkXCIsXCLGjFwiOlwiZFwiLFwixLFcIjpcImlcIixcIsi3XCI6XCJqXCIsXCLJn1wiOlwialwiLFwiyoRcIjpcImpcIixcIsezXCI6XCJkelwiLFwix4ZcIjpcImR6XCIsXCLDqVwiOlwiZVwiLFwixJVcIjpcImVcIixcIsSbXCI6XCJlXCIsXCLIqVwiOlwiZVwiLFwi4bidXCI6XCJlXCIsXCLDqlwiOlwiZVwiLFwi4bq/XCI6XCJlXCIsXCLhu4dcIjpcImVcIixcIuG7gVwiOlwiZVwiLFwi4buDXCI6XCJlXCIsXCLhu4VcIjpcImVcIixcIuG4mVwiOlwiZVwiLFwiw6tcIjpcImVcIixcIsSXXCI6XCJlXCIsXCLhurlcIjpcImVcIixcIsiFXCI6XCJlXCIsXCLDqFwiOlwiZVwiLFwi4bq7XCI6XCJlXCIsXCLIh1wiOlwiZVwiLFwixJNcIjpcImVcIixcIuG4l1wiOlwiZVwiLFwi4biVXCI6XCJlXCIsXCLisbhcIjpcImVcIixcIsSZXCI6XCJlXCIsXCLhtpJcIjpcImVcIixcIsmHXCI6XCJlXCIsXCLhur1cIjpcImVcIixcIuG4m1wiOlwiZVwiLFwi6p2rXCI6XCJldFwiLFwi4bifXCI6XCJmXCIsXCLGklwiOlwiZlwiLFwi4bWuXCI6XCJmXCIsXCLhtoJcIjpcImZcIixcIse1XCI6XCJnXCIsXCLEn1wiOlwiZ1wiLFwix6dcIjpcImdcIixcIsSjXCI6XCJnXCIsXCLEnVwiOlwiZ1wiLFwixKFcIjpcImdcIixcIsmgXCI6XCJnXCIsXCLhuKFcIjpcImdcIixcIuG2g1wiOlwiZ1wiLFwix6VcIjpcImdcIixcIuG4q1wiOlwiaFwiLFwiyJ9cIjpcImhcIixcIuG4qVwiOlwiaFwiLFwixKVcIjpcImhcIixcIuKxqFwiOlwiaFwiLFwi4binXCI6XCJoXCIsXCLhuKNcIjpcImhcIixcIuG4pVwiOlwiaFwiLFwiyaZcIjpcImhcIixcIuG6llwiOlwiaFwiLFwixKdcIjpcImhcIixcIsaVXCI6XCJodlwiLFwiw61cIjpcImlcIixcIsStXCI6XCJpXCIsXCLHkFwiOlwiaVwiLFwiw65cIjpcImlcIixcIsOvXCI6XCJpXCIsXCLhuK9cIjpcImlcIixcIuG7i1wiOlwiaVwiLFwiyIlcIjpcImlcIixcIsOsXCI6XCJpXCIsXCLhu4lcIjpcImlcIixcIsiLXCI6XCJpXCIsXCLEq1wiOlwiaVwiLFwixK9cIjpcImlcIixcIuG2llwiOlwiaVwiLFwiyahcIjpcImlcIixcIsSpXCI6XCJpXCIsXCLhuK1cIjpcImlcIixcIuqdulwiOlwiZFwiLFwi6p28XCI6XCJmXCIsXCLhtblcIjpcImdcIixcIuqeg1wiOlwiclwiLFwi6p6FXCI6XCJzXCIsXCLqnodcIjpcInRcIixcIuqdrVwiOlwiaXNcIixcIsewXCI6XCJqXCIsXCLEtVwiOlwialwiLFwiyp1cIjpcImpcIixcIsmJXCI6XCJqXCIsXCLhuLFcIjpcImtcIixcIsepXCI6XCJrXCIsXCLEt1wiOlwia1wiLFwi4rGqXCI6XCJrXCIsXCLqnYNcIjpcImtcIixcIuG4s1wiOlwia1wiLFwixplcIjpcImtcIixcIuG4tVwiOlwia1wiLFwi4baEXCI6XCJrXCIsXCLqnYFcIjpcImtcIixcIuqdhVwiOlwia1wiLFwixLpcIjpcImxcIixcIsaaXCI6XCJsXCIsXCLJrFwiOlwibFwiLFwixL5cIjpcImxcIixcIsS8XCI6XCJsXCIsXCLhuL1cIjpcImxcIixcIsi0XCI6XCJsXCIsXCLhuLdcIjpcImxcIixcIuG4uVwiOlwibFwiLFwi4rGhXCI6XCJsXCIsXCLqnYlcIjpcImxcIixcIuG4u1wiOlwibFwiLFwixYBcIjpcImxcIixcIsmrXCI6XCJsXCIsXCLhtoVcIjpcImxcIixcIsmtXCI6XCJsXCIsXCLFglwiOlwibFwiLFwix4lcIjpcImxqXCIsXCLFv1wiOlwic1wiLFwi4bqcXCI6XCJzXCIsXCLhuptcIjpcInNcIixcIuG6nVwiOlwic1wiLFwi4bi/XCI6XCJtXCIsXCLhuYFcIjpcIm1cIixcIuG5g1wiOlwibVwiLFwiybFcIjpcIm1cIixcIuG1r1wiOlwibVwiLFwi4baGXCI6XCJtXCIsXCLFhFwiOlwiblwiLFwixYhcIjpcIm5cIixcIsWGXCI6XCJuXCIsXCLhuYtcIjpcIm5cIixcIsi1XCI6XCJuXCIsXCLhuYVcIjpcIm5cIixcIuG5h1wiOlwiblwiLFwix7lcIjpcIm5cIixcIsmyXCI6XCJuXCIsXCLhuYlcIjpcIm5cIixcIsaeXCI6XCJuXCIsXCLhtbBcIjpcIm5cIixcIuG2h1wiOlwiblwiLFwiybNcIjpcIm5cIixcIsOxXCI6XCJuXCIsXCLHjFwiOlwibmpcIixcIsOzXCI6XCJvXCIsXCLFj1wiOlwib1wiLFwix5JcIjpcIm9cIixcIsO0XCI6XCJvXCIsXCLhu5FcIjpcIm9cIixcIuG7mVwiOlwib1wiLFwi4buTXCI6XCJvXCIsXCLhu5VcIjpcIm9cIixcIuG7l1wiOlwib1wiLFwiw7ZcIjpcIm9cIixcIsirXCI6XCJvXCIsXCLIr1wiOlwib1wiLFwiyLFcIjpcIm9cIixcIuG7jVwiOlwib1wiLFwixZFcIjpcIm9cIixcIsiNXCI6XCJvXCIsXCLDslwiOlwib1wiLFwi4buPXCI6XCJvXCIsXCLGoVwiOlwib1wiLFwi4bubXCI6XCJvXCIsXCLhu6NcIjpcIm9cIixcIuG7nVwiOlwib1wiLFwi4bufXCI6XCJvXCIsXCLhu6FcIjpcIm9cIixcIsiPXCI6XCJvXCIsXCLqnYtcIjpcIm9cIixcIuqdjVwiOlwib1wiLFwi4rG6XCI6XCJvXCIsXCLFjVwiOlwib1wiLFwi4bmTXCI6XCJvXCIsXCLhuZFcIjpcIm9cIixcIserXCI6XCJvXCIsXCLHrVwiOlwib1wiLFwiw7hcIjpcIm9cIixcIse/XCI6XCJvXCIsXCLDtVwiOlwib1wiLFwi4bmNXCI6XCJvXCIsXCLhuY9cIjpcIm9cIixcIsitXCI6XCJvXCIsXCLGo1wiOlwib2lcIixcIuqdj1wiOlwib29cIixcIsmbXCI6XCJlXCIsXCLhtpNcIjpcImVcIixcIsmUXCI6XCJvXCIsXCLhtpdcIjpcIm9cIixcIsijXCI6XCJvdVwiLFwi4bmVXCI6XCJwXCIsXCLhuZdcIjpcInBcIixcIuqdk1wiOlwicFwiLFwixqVcIjpcInBcIixcIuG1sVwiOlwicFwiLFwi4baIXCI6XCJwXCIsXCLqnZVcIjpcInBcIixcIuG1vVwiOlwicFwiLFwi6p2RXCI6XCJwXCIsXCLqnZlcIjpcInFcIixcIsqgXCI6XCJxXCIsXCLJi1wiOlwicVwiLFwi6p2XXCI6XCJxXCIsXCLFlVwiOlwiclwiLFwixZlcIjpcInJcIixcIsWXXCI6XCJyXCIsXCLhuZlcIjpcInJcIixcIuG5m1wiOlwiclwiLFwi4bmdXCI6XCJyXCIsXCLIkVwiOlwiclwiLFwiyb5cIjpcInJcIixcIuG1s1wiOlwiclwiLFwiyJNcIjpcInJcIixcIuG5n1wiOlwiclwiLFwiybxcIjpcInJcIixcIuG1slwiOlwiclwiLFwi4baJXCI6XCJyXCIsXCLJjVwiOlwiclwiLFwiyb1cIjpcInJcIixcIuKGhFwiOlwiY1wiLFwi6py/XCI6XCJjXCIsXCLJmFwiOlwiZVwiLFwiyb9cIjpcInJcIixcIsWbXCI6XCJzXCIsXCLhuaVcIjpcInNcIixcIsWhXCI6XCJzXCIsXCLhuadcIjpcInNcIixcIsWfXCI6XCJzXCIsXCLFnVwiOlwic1wiLFwiyJlcIjpcInNcIixcIuG5oVwiOlwic1wiLFwi4bmjXCI6XCJzXCIsXCLhualcIjpcInNcIixcIsqCXCI6XCJzXCIsXCLhtbRcIjpcInNcIixcIuG2ilwiOlwic1wiLFwiyL9cIjpcInNcIixcIsmhXCI6XCJnXCIsXCLDn1wiOlwic3NcIixcIuG0kVwiOlwib1wiLFwi4bSTXCI6XCJvXCIsXCLhtJ1cIjpcInVcIixcIsWlXCI6XCJ0XCIsXCLFo1wiOlwidFwiLFwi4bmxXCI6XCJ0XCIsXCLIm1wiOlwidFwiLFwiyLZcIjpcInRcIixcIuG6l1wiOlwidFwiLFwi4rGmXCI6XCJ0XCIsXCLhuatcIjpcInRcIixcIuG5rVwiOlwidFwiLFwixq1cIjpcInRcIixcIuG5r1wiOlwidFwiLFwi4bW1XCI6XCJ0XCIsXCLGq1wiOlwidFwiLFwiyohcIjpcInRcIixcIsWnXCI6XCJ0XCIsXCLhtbpcIjpcInRoXCIsXCLJkFwiOlwiYVwiLFwi4bSCXCI6XCJhZVwiLFwix51cIjpcImVcIixcIuG1t1wiOlwiZ1wiLFwiyaVcIjpcImhcIixcIsquXCI6XCJoXCIsXCLKr1wiOlwiaFwiLFwi4bSJXCI6XCJpXCIsXCLKnlwiOlwia1wiLFwi6p6BXCI6XCJsXCIsXCLJr1wiOlwibVwiLFwiybBcIjpcIm1cIixcIuG0lFwiOlwib2VcIixcIsm5XCI6XCJyXCIsXCLJu1wiOlwiclwiLFwiybpcIjpcInJcIixcIuKxuVwiOlwiclwiLFwiyodcIjpcInRcIixcIsqMXCI6XCJ2XCIsXCLKjVwiOlwid1wiLFwiyo5cIjpcInlcIixcIuqcqVwiOlwidHpcIixcIsO6XCI6XCJ1XCIsXCLFrVwiOlwidVwiLFwix5RcIjpcInVcIixcIsO7XCI6XCJ1XCIsXCLhubdcIjpcInVcIixcIsO8XCI6XCJ1XCIsXCLHmFwiOlwidVwiLFwix5pcIjpcInVcIixcIsecXCI6XCJ1XCIsXCLHllwiOlwidVwiLFwi4bmzXCI6XCJ1XCIsXCLhu6VcIjpcInVcIixcIsWxXCI6XCJ1XCIsXCLIlVwiOlwidVwiLFwiw7lcIjpcInVcIixcIuG7p1wiOlwidVwiLFwixrBcIjpcInVcIixcIuG7qVwiOlwidVwiLFwi4buxXCI6XCJ1XCIsXCLhu6tcIjpcInVcIixcIuG7rVwiOlwidVwiLFwi4buvXCI6XCJ1XCIsXCLIl1wiOlwidVwiLFwixatcIjpcInVcIixcIuG5u1wiOlwidVwiLFwixbNcIjpcInVcIixcIuG2mVwiOlwidVwiLFwixa9cIjpcInVcIixcIsWpXCI6XCJ1XCIsXCLhublcIjpcInVcIixcIuG5tVwiOlwidVwiLFwi4bWrXCI6XCJ1ZVwiLFwi6p24XCI6XCJ1bVwiLFwi4rG0XCI6XCJ2XCIsXCLqnZ9cIjpcInZcIixcIuG5v1wiOlwidlwiLFwiyotcIjpcInZcIixcIuG2jFwiOlwidlwiLFwi4rGxXCI6XCJ2XCIsXCLhub1cIjpcInZcIixcIuqdoVwiOlwidnlcIixcIuG6g1wiOlwid1wiLFwixbVcIjpcIndcIixcIuG6hVwiOlwid1wiLFwi4bqHXCI6XCJ3XCIsXCLhuolcIjpcIndcIixcIuG6gVwiOlwid1wiLFwi4rGzXCI6XCJ3XCIsXCLhuphcIjpcIndcIixcIuG6jVwiOlwieFwiLFwi4bqLXCI6XCJ4XCIsXCLhto1cIjpcInhcIixcIsO9XCI6XCJ5XCIsXCLFt1wiOlwieVwiLFwiw79cIjpcInlcIixcIuG6j1wiOlwieVwiLFwi4bu1XCI6XCJ5XCIsXCLhu7NcIjpcInlcIixcIsa0XCI6XCJ5XCIsXCLhu7dcIjpcInlcIixcIuG7v1wiOlwieVwiLFwiyLNcIjpcInlcIixcIuG6mVwiOlwieVwiLFwiyY9cIjpcInlcIixcIuG7uVwiOlwieVwiLFwixbpcIjpcInpcIixcIsW+XCI6XCJ6XCIsXCLhupFcIjpcInpcIixcIsqRXCI6XCJ6XCIsXCLisaxcIjpcInpcIixcIsW8XCI6XCJ6XCIsXCLhupNcIjpcInpcIixcIsilXCI6XCJ6XCIsXCLhupVcIjpcInpcIixcIuG1tlwiOlwielwiLFwi4baOXCI6XCJ6XCIsXCLKkFwiOlwielwiLFwixrZcIjpcInpcIixcIsmAXCI6XCJ6XCIsXCLvrIBcIjpcImZmXCIsXCLvrINcIjpcImZmaVwiLFwi76yEXCI6XCJmZmxcIixcIu+sgVwiOlwiZmlcIixcIu+sglwiOlwiZmxcIixcIsSzXCI6XCJpalwiLFwixZNcIjpcIm9lXCIsXCLvrIZcIjpcInN0XCIsXCLigpBcIjpcImFcIixcIuKCkVwiOlwiZVwiLFwi4bWiXCI6XCJpXCIsXCLisbxcIjpcImpcIixcIuKCklwiOlwib1wiLFwi4bWjXCI6XCJyXCIsXCLhtaRcIjpcInVcIixcIuG1pVwiOlwidlwiLFwi4oKTXCI6XCJ4XCJ9O1xuXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gQWRkZWQgYW4gaW5pdGlhbGl6ZSBmdW5jdGlvbiB3aGljaCBpcyBlc3NlbnRpYWxseSB0aGUgY29kZSBmcm9tIHRoZSBTXG4vLyBjb25zdHJ1Y3Rvci4gIE5vdywgdGhlIFMgY29uc3RydWN0b3IgY2FsbHMgdGhpcyBhbmQgYSBuZXcgbWV0aG9kIG5hbWVkXG4vLyBzZXRWYWx1ZSBjYWxscyBpdCBhcyB3ZWxsLiAgVGhlIHNldFZhbHVlIGZ1bmN0aW9uIGFsbG93cyBjb25zdHJ1Y3RvcnMgZm9yXG4vLyBtb2R1bGVzIHRoYXQgZXh0ZW5kIHN0cmluZy5qcyB0byBzZXQgdGhlIGluaXRpYWwgdmFsdWUgb2YgYW4gb2JqZWN0IHdpdGhvdXRcbi8vIGtub3dpbmcgdGhlIGludGVybmFsIHdvcmtpbmdzIG9mIHN0cmluZy5qcy5cbi8vXG4vLyBBbHNvLCBhbGwgbWV0aG9kcyB3aGljaCByZXR1cm4gYSBuZXcgUyBvYmplY3Qgbm93IGNhbGw6XG4vL1xuLy8gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Iocyk7XG4vL1xuLy8gaW5zdGVhZCBvZjpcbi8vXG4vLyAgICAgIHJldHVybiBuZXcgUyhzKTtcbi8vXG4vLyBUaGlzIGFsbG93cyBleHRlbmRlZCBvYmplY3RzIHRvIGtlZXAgdGhlaXIgcHJvcGVyIGluc3RhbmNlT2YgYW5kIGNvbnN0cnVjdG9yLlxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBmdW5jdGlvbiBpbml0aWFsaXplIChvYmplY3QsIHMpIHtcbiAgICBpZiAocyAhPT0gbnVsbCAmJiBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9iamVjdC5zID0gcztcbiAgICAgIGVsc2VcbiAgICAgICAgb2JqZWN0LnMgPSBzLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdC5zID0gczsgLy9udWxsIG9yIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIG9iamVjdC5vcmlnID0gczsgLy9vcmlnaW5hbCBvYmplY3QsIGN1cnJlbnRseSBvbmx5IHVzZWQgYnkgdG9DU1YoKSBhbmQgdG9Cb29sZWFuKClcblxuICAgIGlmIChzICE9PSBudWxsICYmIHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9iamVjdC5fX2RlZmluZUdldHRlcl9fKSB7XG4gICAgICAgIG9iamVjdC5fX2RlZmluZUdldHRlcl9fKCdsZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0LnMubGVuZ3RoO1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0Lmxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QubGVuZ3RoID0gLTE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gUyhzKSB7XG4gIFx0aW5pdGlhbGl6ZSh0aGlzLCBzKTtcbiAgfVxuXG4gIHZhciBfX25zcCA9IFN0cmluZy5wcm90b3R5cGU7XG4gIHZhciBfX3NwID0gUy5wcm90b3R5cGUgPSB7XG5cbiAgICBiZXR3ZWVuOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIHMgPSB0aGlzLnM7XG4gICAgICB2YXIgc3RhcnRQb3MgPSBzLmluZGV4T2YobGVmdCk7XG4gICAgICB2YXIgZW5kUG9zID0gcy5pbmRleE9mKHJpZ2h0LCBzdGFydFBvcyArIGxlZnQubGVuZ3RoKTtcbiAgICAgIGlmIChlbmRQb3MgPT0gLTEgJiYgcmlnaHQgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCcnKVxuICAgICAgZWxzZSBpZiAoZW5kUG9zID09IC0xICYmIHJpZ2h0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzLnN1YnN0cmluZyhzdGFydFBvcyArIGxlZnQubGVuZ3RoKSlcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHMuc2xpY2Uoc3RhcnRQb3MgKyBsZWZ0Lmxlbmd0aCwgZW5kUG9zKSk7XG4gICAgfSxcblxuICAgIC8vIyBtb2RpZmllZCBzbGlnaHRseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcGVsaS91bmRlcnNjb3JlLnN0cmluZ1xuICAgIGNhbWVsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gdGhpcy50cmltKCkucy5yZXBsYWNlKC8oXFwtfF98XFxzKSsoLik/L2csIGZ1bmN0aW9uKG1hdGhjLCBzZXAsIGMpIHtcbiAgICAgICAgcmV0dXJuIChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Iocyk7XG4gICAgfSxcblxuICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucy5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHRoaXMucy5zdWJzdHJpbmcoMSkudG9Mb3dlckNhc2UoKSk7XG4gICAgfSxcblxuICAgIGNoYXJBdDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnMuY2hhckF0KGluZGV4KTtcbiAgICB9LFxuXG4gICAgY2hvbXBMZWZ0OiBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zO1xuICAgICAgaWYgKHMuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICBzID0gcy5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaG9tcFJpZ2h0OiBmdW5jdGlvbihzdWZmaXgpIHtcbiAgICAgIGlmICh0aGlzLmVuZHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnM7XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIHMubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyN0aGFua3MgR29vZ2xlXG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zLnJlcGxhY2UoL1tcXHNcXHhhMF0rL2csICcgJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHMpO1xuICAgIH0sXG5cbiAgICBjb250YWluczogZnVuY3Rpb24oc3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnMuaW5kZXhPZihzcykgPj0gMDtcbiAgICB9LFxuXG4gICAgY291bnQ6IGZ1bmN0aW9uKHNzKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgnLi9fY291bnQnKSh0aGlzLnMsIHNzKVxuICAgIH0sXG5cbiAgICAvLyNtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcGVsaS91bmRlcnNjb3JlLnN0cmluZ1xuICAgIGRhc2hlcml6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcyA9IHRoaXMudHJpbSgpLnMucmVwbGFjZSgvW19cXHNdKy9nLCAnLScpLnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnJlcGxhY2UoLy0rL2csICctJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzKTtcbiAgICB9LFxuXG4gICAgbGF0aW5pc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHMgPSB0aGlzLnJlcGxhY2UoL1teQS1aYS16MC05XFxbXFxdIF0vZywgZnVuY3Rpb24oeCkgeyByZXR1cm4gbGF0aW5fbWFwW3hdIHx8IHg7IH0pO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHMpO1xuICAgIH0sXG5cbiAgICBkZWNvZGVIdG1sRW50aXRpZXM6IGZ1bmN0aW9uKCkgeyAvL2h0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9ub2RlLWVudC9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgICAgdmFyIHMgPSB0aGlzLnM7XG4gICAgICBzID0gcy5yZXBsYWNlKC8mIyhcXGQrKTs/L2csIGZ1bmN0aW9uIChfLCBjb2RlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKC8mI1t4WF0oW0EtRmEtZjAtOV0rKTs/L2csIGZ1bmN0aW9uIChfLCBoZXgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKC8mKFteO1xcV10rOz8pL2csIGZ1bmN0aW9uIChtLCBlKSB7XG4gICAgICAgIHZhciBlZSA9IGUucmVwbGFjZSgvOyQvLCAnJyk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBFTlRJVElFU1tlXSB8fCAoZS5tYXRjaCgvOyQvKSAmJiBFTlRJVElFU1tlZV0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Iocyk7XG4gICAgfSxcblxuICAgIGVuZHNXaXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdWZmaXhlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1ZmZpeGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsICA9IHRoaXMucy5sZW5ndGggLSBzdWZmaXhlc1tpXS5sZW5ndGg7XG4gICAgICAgIGlmIChsID49IDAgJiYgdGhpcy5zLmluZGV4T2Yoc3VmZml4ZXNbaV0sIGwpID09PSBsKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZXNjYXBlSFRNTDogZnVuY3Rpb24oKSB7IC8vZnJvbSB1bmRlcnNjb3JlLnN0cmluZ1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucy5yZXBsYWNlKC9bJjw+XCInXS9nLCBmdW5jdGlvbihtKXsgcmV0dXJuICcmJyArIHJldmVyc2VkRXNjYXBlQ2hhcnNbbV0gKyAnOyc7IH0pKTtcbiAgICB9LFxuXG4gICAgZW5zdXJlTGVmdDogZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICB2YXIgcyA9IHRoaXMucztcbiAgICAgIGlmIChzLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihwcmVmaXggKyBzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5zdXJlUmlnaHQ6IGZ1bmN0aW9uKHN1ZmZpeCkge1xuICAgICAgdmFyIHMgPSB0aGlzLnM7XG4gICAgICBpZiAodGhpcy5lbmRzV2l0aChzdWZmaXgpKSAge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzICsgc3VmZml4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaHVtYW5pemU6IGZ1bmN0aW9uKCkgeyAvL21vZGlmaWVkIGZyb20gdW5kZXJzY29yZS5zdHJpbmdcbiAgICAgIGlmICh0aGlzLnMgPT09IG51bGwgfHwgdGhpcy5zID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcignJylcbiAgICAgIHZhciBzID0gdGhpcy51bmRlcnNjb3JlKCkucmVwbGFjZSgvX2lkJC8sJycpLnJlcGxhY2UoL18vZywgJyAnKS50cmltKCkuY2FwaXRhbGl6ZSgpXG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IocylcbiAgICB9LFxuXG4gICAgaXNBbHBoYTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIS9bXmEtelxceERGLVxceEZGXXxeJC8udGVzdCh0aGlzLnMudG9Mb3dlckNhc2UoKSk7XG4gICAgfSxcblxuICAgIGlzQWxwaGFOdW1lcmljOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhL1teMC05YS16XFx4REYtXFx4RkZdLy50ZXN0KHRoaXMucy50b0xvd2VyQ2FzZSgpKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zID09PSBudWxsIHx8IHRoaXMucyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IC9eW1xcc1xceGEwXSokLy50ZXN0KHRoaXMucyk7XG4gICAgfSxcblxuICAgIGlzTG93ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNBbHBoYSgpICYmIHRoaXMucy50b0xvd2VyQ2FzZSgpID09PSB0aGlzLnM7XG4gICAgfSxcblxuICAgIGlzTnVtZXJpYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIS9bXjAtOV0vLnRlc3QodGhpcy5zKTtcbiAgICB9LFxuXG4gICAgaXNVcHBlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0FscGhhKCkgJiYgdGhpcy5zLnRvVXBwZXJDYXNlKCkgPT09IHRoaXMucztcbiAgICB9LFxuXG4gICAgbGVmdDogZnVuY3Rpb24oTikge1xuICAgICAgaWYgKE4gPj0gMCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMucy5zdWJzdHIoMCwgTik7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0KC1OKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGluZXM6IGZ1bmN0aW9uKCkgeyAvL2NvbnZlcnQgd2luZG93cyBuZXdsaW5lcyB0byB1bml4IG5ld2xpbmVzIHRoZW4gY29udmVydCB0byBhbiBBcnJheSBvZiBsaW5lc1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZUFsbCgnXFxyXFxuJywgJ1xcbicpLnMuc3BsaXQoJ1xcbicpO1xuICAgIH0sXG5cbiAgICBwYWQ6IGZ1bmN0aW9uKGxlbiwgY2gpIHsgLy9odHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L3BhZFxuICAgICAgaWYgKGNoID09IG51bGwpIGNoID0gJyAnO1xuICAgICAgaWYgKHRoaXMucy5sZW5ndGggPj0gbGVuKSByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5zKTtcbiAgICAgIGxlbiA9IGxlbiAtIHRoaXMucy5sZW5ndGg7XG4gICAgICB2YXIgbGVmdCA9IEFycmF5KE1hdGguY2VpbChsZW4gLyAyKSArIDEpLmpvaW4oY2gpO1xuICAgICAgdmFyIHJpZ2h0ID0gQXJyYXkoTWF0aC5mbG9vcihsZW4gLyAyKSArIDEpLmpvaW4oY2gpO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKGxlZnQgKyB0aGlzLnMgKyByaWdodCk7XG4gICAgfSxcblxuICAgIHBhZExlZnQ6IGZ1bmN0aW9uKGxlbiwgY2gpIHsgLy9odHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L3BhZFxuICAgICAgaWYgKGNoID09IG51bGwpIGNoID0gJyAnO1xuICAgICAgaWYgKHRoaXMucy5sZW5ndGggPj0gbGVuKSByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5zKTtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihBcnJheShsZW4gLSB0aGlzLnMubGVuZ3RoICsgMSkuam9pbihjaCkgKyB0aGlzLnMpO1xuICAgIH0sXG5cbiAgICBwYWRSaWdodDogZnVuY3Rpb24obGVuLCBjaCkgeyAvL2h0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvcGFkXG4gICAgICBpZiAoY2ggPT0gbnVsbCkgY2ggPSAnICc7XG4gICAgICBpZiAodGhpcy5zLmxlbmd0aCA+PSBsZW4pIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnMpO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucyArIEFycmF5KGxlbiAtIHRoaXMucy5sZW5ndGggKyAxKS5qb2luKGNoKSk7XG4gICAgfSxcblxuICAgIHBhcnNlQ1NWOiBmdW5jdGlvbihkZWxpbWl0ZXIsIHF1YWxpZmllciwgZXNjYXBlLCBsaW5lRGVsaW1pdGVyKSB7IC8vdHJ5IHRvIHBhcnNlIG5vIG1hdHRlciB3aGF0XG4gICAgICBkZWxpbWl0ZXIgPSBkZWxpbWl0ZXIgfHwgJywnO1xuICAgICAgZXNjYXBlID0gZXNjYXBlIHx8ICdcXFxcJ1xuICAgICAgaWYgKHR5cGVvZiBxdWFsaWZpZXIgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHF1YWxpZmllciA9ICdcIic7XG5cbiAgICAgIHZhciBpID0gMCwgZmllbGRCdWZmZXIgPSBbXSwgZmllbGRzID0gW10sIGxlbiA9IHRoaXMucy5sZW5ndGgsIGluRmllbGQgPSBmYWxzZSwgaW5VbnF1YWxpZmllZFN0cmluZyA9IGZhbHNlLCBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjYSA9IGZ1bmN0aW9uKGkpe3JldHVybiBzZWxmLnMuY2hhckF0KGkpfTtcbiAgICAgIGlmICh0eXBlb2YgbGluZURlbGltaXRlciAhPT0gJ3VuZGVmaW5lZCcpIHZhciByb3dzID0gW107XG5cbiAgICAgIGlmICghcXVhbGlmaWVyKVxuICAgICAgICBpbkZpZWxkID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjYShpKTtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50KSB7XG4gICAgICAgICAgY2FzZSBlc2NhcGU6XG4gICAgICAgICAgICAvL2ZpeCBmb3IgaXNzdWVzICMzMiBhbmQgIzM1XG4gICAgICAgICAgICBpZiAoaW5GaWVsZCAmJiAoKGVzY2FwZSAhPT0gcXVhbGlmaWVyKSB8fCBjYShpKzEpID09PSBxdWFsaWZpZXIpKSB7XG4gICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgZmllbGRCdWZmZXIucHVzaChjYShpKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVzY2FwZSAhPT0gcXVhbGlmaWVyKSBicmVhaztcbiAgICAgICAgICBjYXNlIHF1YWxpZmllcjpcbiAgICAgICAgICAgIGluRmllbGQgPSAhaW5GaWVsZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZGVsaW1pdGVyOlxuICAgICAgICAgICAgaWYoaW5VbnF1YWxpZmllZFN0cmluZykge1xuICAgICAgICAgICAgICBpbkZpZWxkPWZhbHNlO1xuICAgICAgICAgICAgICBpblVucXVhbGlmaWVkU3RyaW5nPWZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluRmllbGQgJiYgcXVhbGlmaWVyKVxuICAgICAgICAgICAgICBmaWVsZEJ1ZmZlci5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkQnVmZmVyLmpvaW4oJycpKVxuICAgICAgICAgICAgICBmaWVsZEJ1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBsaW5lRGVsaW1pdGVyOlxuICAgICAgICAgICAgaWYoaW5VbnF1YWxpZmllZFN0cmluZykge1xuICAgICAgICAgICAgICBpbkZpZWxkPWZhbHNlO1xuICAgICAgICAgICAgICBpblVucXVhbGlmaWVkU3RyaW5nPWZhbHNlO1xuICAgICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZEJ1ZmZlci5qb2luKCcnKSlcbiAgICAgICAgICAgICAgcm93cy5wdXNoKGZpZWxkcyk7XG4gICAgICAgICAgICAgIGZpZWxkcyA9IFtdO1xuICAgICAgICAgICAgICBmaWVsZEJ1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5GaWVsZCkge1xuICAgICAgICAgICAgICBmaWVsZEJ1ZmZlci5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHJvd3MpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZEJ1ZmZlci5qb2luKCcnKSlcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goZmllbGRzKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEJ1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIGlmIChpbkZpZWxkKVxuICAgICAgICAgICAgICBmaWVsZEJ1ZmZlci5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpbkZpZWxkKVxuICAgICAgICAgICAgICBmaWVsZEJ1ZmZlci5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgZWxzZSBpZihjdXJyZW50IT09cXVhbGlmaWVyKSB7XG4gICAgICAgICAgICAgIGZpZWxkQnVmZmVyLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgIGluRmllbGQ9dHJ1ZTtcbiAgICAgICAgICAgICAgaW5VbnF1YWxpZmllZFN0cmluZz10cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBmaWVsZHMucHVzaChmaWVsZEJ1ZmZlci5qb2luKCcnKSk7XG4gICAgICBpZiAocm93cykge1xuICAgICAgICByb3dzLnB1c2goZmllbGRzKTtcbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmllbGRzO1xuICAgIH0sXG5cbiAgICByZXBsYWNlQWxsOiBmdW5jdGlvbihzcywgcikge1xuICAgICAgLy92YXIgcyA9IHRoaXMucy5yZXBsYWNlKG5ldyBSZWdFeHAoc3MsICdnJyksIHIpO1xuICAgICAgdmFyIHMgPSB0aGlzLnMuc3BsaXQoc3MpLmpvaW4ocilcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzKTtcbiAgICB9LFxuXG4gICAgc3RyaXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNzID0gdGhpcy5zO1xuICAgICAgZm9yKHZhciBpPSAwLCBuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bjsgaSsrKSB7XG4gICAgICAgIHNzID0gc3Muc3BsaXQoYXJndW1lbnRzW2ldKS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihzcyk7XG4gICAgfSxcblxuICAgIHN0cmlwTGVmdDogZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICB2YXIgcmVnZXg7XG4gICAgICB2YXIgcGF0dGVybjtcbiAgICAgIHZhciBzcyA9IGVuc3VyZVN0cmluZyh0aGlzLnMpO1xuXG4gICAgICBpZiAoY2hhcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXR0ZXJuID0gL15cXHMrL2c7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVnZXggPSBlc2NhcGVSZWdFeHAoY2hhcnMpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl5bXCIgKyByZWdleCArIFwiXStcIiwgXCJnXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioc3MucmVwbGFjZShwYXR0ZXJuLCBcIlwiKSk7XG4gICAgfSxcblxuICAgIHN0cmlwUmlnaHQ6IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgdmFyIHJlZ2V4O1xuICAgICAgdmFyIHBhdHRlcm47XG4gICAgICB2YXIgc3MgPSBlbnN1cmVTdHJpbmcodGhpcy5zKTtcblxuICAgICAgaWYgKGNoYXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGF0dGVybiA9IC9cXHMrJC9nO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlZ2V4ID0gZXNjYXBlUmVnRXhwKGNoYXJzKTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoXCJbXCIgKyByZWdleCArIFwiXSskXCIsIFwiZ1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHNzLnJlcGxhY2UocGF0dGVybiwgXCJcIikpO1xuICAgIH0sXG5cbiAgICByaWdodDogZnVuY3Rpb24oTikge1xuICAgICAgaWYgKE4gPj0gMCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMucy5zdWJzdHIodGhpcy5zLmxlbmd0aCAtIE4sIE4pO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Iocyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0KC1OKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uIChzKSB7XG5cdCAgaW5pdGlhbGl6ZSh0aGlzLCBzKTtcblx0ICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2x1Z2lmeTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2wgPSAobmV3IFMobmV3IFModGhpcy5zKS5sYXRpbmlzZSgpLnMucmVwbGFjZSgvW15cXHdcXHMtXS9nLCAnJykudG9Mb3dlckNhc2UoKSkpLmRhc2hlcml6ZSgpLnM7XG4gICAgICBpZiAoc2wuY2hhckF0KDApID09PSAnLScpXG4gICAgICAgIHNsID0gc2wuc3Vic3RyKDEpO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHNsKTtcbiAgICB9LFxuXG4gICAgc3RhcnRzV2l0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJlZml4ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5zLmxhc3RJbmRleE9mKHByZWZpeGVzW2ldLCAwKSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHN0cmlwUHVuY3R1YXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgLy9yZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5zLnJlcGxhY2UoL1tcXC4sLVxcLyMhJCVcXF4mXFwqOzp7fT1cXC1fYH4oKV0vZyxcIlwiKSk7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5zLnJlcGxhY2UoL1teXFx3XFxzXXxfL2csIFwiXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpKTtcbiAgICB9LFxuXG4gICAgc3RyaXBUYWdzOiBmdW5jdGlvbigpIHsgLy9mcm9tIHN1Z2FyLmpzXG4gICAgICB2YXIgcyA9IHRoaXMucywgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzIDogWycnXTtcbiAgICAgIG11bHRpQXJncyhhcmdzLCBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShSZWdFeHAoJzxcXC8/JyArIHRhZyArICdbXjw+XSo+JywgJ2dpJyksICcnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHMpO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24odmFsdWVzLCBvcGVuaW5nLCBjbG9zaW5nKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuc1xuICAgICAgdmFyIG9wZW5pbmcgPSBvcGVuaW5nIHx8IEV4cG9ydC5UTVBMX09QRU5cbiAgICAgIHZhciBjbG9zaW5nID0gY2xvc2luZyB8fCBFeHBvcnQuVE1QTF9DTE9TRVxuXG4gICAgICB2YXIgb3BlbiA9IG9wZW5pbmcucmVwbGFjZSgvWy1bXFxdKCkqXFxzXS9nLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJylcbiAgICAgIHZhciBjbG9zZSA9IGNsb3NpbmcucmVwbGFjZSgvWy1bXFxdKCkqXFxzXS9nLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJylcbiAgICAgIHZhciByID0gbmV3IFJlZ0V4cChvcGVuICsgJyguKz8pJyArIGNsb3NlLCAnZycpXG4gICAgICAgIC8vLCByID0gL1xce1xceyguKz8pXFx9XFx9L2dcbiAgICAgIHZhciBtYXRjaGVzID0gcy5tYXRjaChyKSB8fCBbXTtcblxuICAgICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHZhciBrZXkgPSBtYXRjaC5zdWJzdHJpbmcob3BlbmluZy5sZW5ndGgsIG1hdGNoLmxlbmd0aCAtIGNsb3NpbmcubGVuZ3RoKS50cmltKCk7Ly9jaG9wIHt7IGFuZCB9fVxuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgdmFsdWVzW2tleV0gPT0gJ3VuZGVmaW5lZCcgPyAnJyA6IHZhbHVlc1trZXldO1xuICAgICAgICBzID0gcy5yZXBsYWNlKG1hdGNoLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzKTtcbiAgICB9LFxuXG4gICAgdGltZXM6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihuZXcgQXJyYXkobiArIDEpLmpvaW4odGhpcy5zKSk7XG4gICAgfSxcblxuICAgIHRvQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3JpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHMgPT09ICd0cnVlJyB8fCBzID09PSAneWVzJyB8fCBzID09PSAnb24nIHx8IHMgPT09ICcxJztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnID09PSB0cnVlIHx8IHRoaXMub3JpZyA9PT0gMTtcbiAgICB9LFxuXG4gICAgdG9GbG9hdDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG4gICAgICB2YXIgbnVtID0gcGFyc2VGbG9hdCh0aGlzLnMpXG4gICAgICBpZiAocHJlY2lzaW9uKVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0udG9GaXhlZChwcmVjaXNpb24pKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbnVtXG4gICAgfSxcblxuICAgIHRvSW50OiBmdW5jdGlvbigpIHsgLy90aGFua3MgR29vZ2xlXG4gICAgICAvLyBJZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoICcweCcgb3IgJy0weCcsIHBhcnNlIGFzIGhleC5cbiAgICAgIHJldHVybiAvXlxccyotPzB4L2kudGVzdCh0aGlzLnMpID8gcGFyc2VJbnQodGhpcy5zLCAxNikgOiBwYXJzZUludCh0aGlzLnMsIDEwKVxuICAgIH0sXG5cbiAgICB0cmltOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzO1xuICAgICAgaWYgKHR5cGVvZiBfX25zcC50cmltID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcyA9IHRoaXMucy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKVxuICAgICAgZWxzZVxuICAgICAgICBzID0gdGhpcy5zLnRyaW0oKVxuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHMpO1xuICAgIH0sXG5cbiAgICB0cmltTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcztcbiAgICAgIGlmIChfX25zcC50cmltTGVmdClcbiAgICAgICAgcyA9IHRoaXMucy50cmltTGVmdCgpO1xuICAgICAgZWxzZVxuICAgICAgICBzID0gdGhpcy5zLnJlcGxhY2UoLyheXFxzKikvZywgJycpO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHMpO1xuICAgIH0sXG5cbiAgICB0cmltUmlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHM7XG4gICAgICBpZiAoX19uc3AudHJpbVJpZ2h0KVxuICAgICAgICBzID0gdGhpcy5zLnRyaW1SaWdodCgpO1xuICAgICAgZWxzZVxuICAgICAgICBzID0gdGhpcy5zLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHMpO1xuICAgIH0sXG5cbiAgICB0cnVuY2F0ZTogZnVuY3Rpb24obGVuZ3RoLCBwcnVuZVN0cikgeyAvL2Zyb20gdW5kZXJzY29yZS5zdHJpbmcsIGF1dGhvcjogZ2l0aHViLmNvbS9yd3pcbiAgICAgIHZhciBzdHIgPSB0aGlzLnM7XG5cbiAgICAgIGxlbmd0aCA9IH5+bGVuZ3RoO1xuICAgICAgcHJ1bmVTdHIgPSBwcnVuZVN0ciB8fCAnLi4uJztcblxuICAgICAgaWYgKHN0ci5sZW5ndGggPD0gbGVuZ3RoKSByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioc3RyKTtcblxuICAgICAgdmFyIHRtcGwgPSBmdW5jdGlvbihjKXsgcmV0dXJuIGMudG9VcHBlckNhc2UoKSAhPT0gYy50b0xvd2VyQ2FzZSgpID8gJ0EnIDogJyAnOyB9LFxuICAgICAgICB0ZW1wbGF0ZSA9IHN0ci5zbGljZSgwLCBsZW5ndGgrMSkucmVwbGFjZSgvLig/PVxcVypcXHcqJCkvZywgdG1wbCk7IC8vICdIZWxsbywgd29ybGQnIC0+ICdIZWxsQUEgQUFBQUEnXG5cbiAgICAgIGlmICh0ZW1wbGF0ZS5zbGljZSh0ZW1wbGF0ZS5sZW5ndGgtMikubWF0Y2goL1xcd1xcdy8pKVxuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL1xccypcXFMrJC8sICcnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGVtcGxhdGUgPSBuZXcgUyh0ZW1wbGF0ZS5zbGljZSgwLCB0ZW1wbGF0ZS5sZW5ndGgtMSkpLnRyaW1SaWdodCgpLnM7XG5cbiAgICAgIHJldHVybiAodGVtcGxhdGUrcHJ1bmVTdHIpLmxlbmd0aCA+IHN0ci5sZW5ndGggPyBuZXcgUyhzdHIpIDogbmV3IFMoc3RyLnNsaWNlKDAsIHRlbXBsYXRlLmxlbmd0aCkrcHJ1bmVTdHIpO1xuICAgIH0sXG5cbiAgICB0b0NTVjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGVsaW0gPSAnLCcsIHF1YWxpZmllciA9ICdcIicsIGVzY2FwZSA9ICdcXFxcJywgZW5jbG9zZU51bWJlcnMgPSB0cnVlLCBrZXlzID0gZmFsc2U7XG4gICAgICB2YXIgZGF0YUFycmF5ID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGhhc1ZhbChpdCkge1xuICAgICAgICByZXR1cm4gaXQgIT09IG51bGwgJiYgaXQgIT09ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZGVsaW0gPSBhcmd1bWVudHNbMF0uZGVsaW1pdGVyIHx8IGRlbGltO1xuICAgICAgICBkZWxpbSA9IGFyZ3VtZW50c1swXS5zZXBhcmF0b3IgfHwgZGVsaW07XG4gICAgICAgIHF1YWxpZmllciA9IGFyZ3VtZW50c1swXS5xdWFsaWZpZXIgfHwgcXVhbGlmaWVyO1xuICAgICAgICBlbmNsb3NlTnVtYmVycyA9ICEhYXJndW1lbnRzWzBdLmVuY2xvc2VOdW1iZXJzO1xuICAgICAgICBlc2NhcGUgPSBhcmd1bWVudHNbMF0uZXNjYXBlIHx8IGVzY2FwZTtcbiAgICAgICAga2V5cyA9ICEhYXJndW1lbnRzWzBdLmtleXM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRlbGltID0gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHF1YWxpZmllciA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgaWYgKGFyZ3VtZW50c1sxXSA9PT0gbnVsbClcbiAgICAgICAgcXVhbGlmaWVyID0gbnVsbDtcblxuICAgICAgIGlmICh0aGlzLm9yaWcgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgZGF0YUFycmF5ICA9IHRoaXMub3JpZztcbiAgICAgIGVsc2UgeyAvL29iamVjdFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5vcmlnKVxuICAgICAgICAgIGlmICh0aGlzLm9yaWcuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIGlmIChrZXlzKVxuICAgICAgICAgICAgICBkYXRhQXJyYXkucHVzaChrZXkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh0aGlzLm9yaWdba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXAgPSBlc2NhcGUgKyBxdWFsaWZpZXI7XG4gICAgICB2YXIgYnVpbGRTdHJpbmcgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzaG91bGRRdWFsaWZ5ID0gaGFzVmFsKHF1YWxpZmllcilcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhQXJyYXlbaV0gPT0gJ251bWJlcicpXG4gICAgICAgICAgc2hvdWxkUXVhbGlmeSAmPSBlbmNsb3NlTnVtYmVycztcblxuICAgICAgICBpZiAoc2hvdWxkUXVhbGlmeSlcbiAgICAgICAgICBidWlsZFN0cmluZy5wdXNoKHF1YWxpZmllcik7XG5cbiAgICAgICAgaWYgKGRhdGFBcnJheVtpXSAhPT0gbnVsbCAmJiBkYXRhQXJyYXlbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBkID0gbmV3IFMoZGF0YUFycmF5W2ldKS5yZXBsYWNlQWxsKHF1YWxpZmllciwgcmVwKS5zO1xuICAgICAgICAgIGJ1aWxkU3RyaW5nLnB1c2goZCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGJ1aWxkU3RyaW5nLnB1c2goJycpXG5cbiAgICAgICAgaWYgKHNob3VsZFF1YWxpZnkpXG4gICAgICAgICAgYnVpbGRTdHJpbmcucHVzaChxdWFsaWZpZXIpO1xuXG4gICAgICAgIGlmIChkZWxpbSlcbiAgICAgICAgICBidWlsZFN0cmluZy5wdXNoKGRlbGltKTtcbiAgICAgIH1cblxuICAgICAgLy9jaG9wIGxhc3QgZGVsaW1cbiAgICAgIC8vY29uc29sZS5sb2coYnVpbGRTdHJpbmcubGVuZ3RoKVxuICAgICAgYnVpbGRTdHJpbmcubGVuZ3RoID0gYnVpbGRTdHJpbmcubGVuZ3RoIC0gMTtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihidWlsZFN0cmluZy5qb2luKCcnKSk7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgfSxcblxuICAgIC8vI21vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VwZWxpL3VuZGVyc2NvcmUuc3RyaW5nXG4gICAgdW5kZXJzY29yZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcyA9IHRoaXMudHJpbSgpLnMucmVwbGFjZSgvKFthLXpcXGRdKShbQS1aXSspL2csICckMV8kMicpLnJlcGxhY2UoLyhbQS1aXFxkXSspKFtBLVpdW2Etel0pLywnJDFfJDInKS5yZXBsYWNlKC9bLVxcc10rL2csICdfJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzKTtcbiAgICB9LFxuXG4gICAgdW5lc2NhcGVIVE1MOiBmdW5jdGlvbigpIHsgLy9mcm9tIHVuZGVyc2NvcmUuc3RyaW5nXG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5zLnJlcGxhY2UoL1xcJihbXjtdKyk7L2csIGZ1bmN0aW9uKGVudGl0eSwgZW50aXR5Q29kZSl7XG4gICAgICAgIHZhciBtYXRjaDtcblxuICAgICAgICBpZiAoZW50aXR5Q29kZSBpbiBlc2NhcGVDaGFycykge1xuICAgICAgICAgIHJldHVybiBlc2NhcGVDaGFyc1tlbnRpdHlDb2RlXTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IGVudGl0eUNvZGUubWF0Y2goL14jeChbXFxkYS1mQS1GXSspJC8pKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobWF0Y2hbMV0sIDE2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBlbnRpdHlDb2RlLm1hdGNoKC9eIyhcXGQrKSQvKSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKH5+bWF0Y2hbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgLy8jQWRkZWQgYSBOZXcgRnVuY3Rpb24gY2FsbGVkIHdyYXBIVE1MLlxuICAgIHdyYXBIVE1MOiBmdW5jdGlvbiAodGFnTmFtZSwgdGFnQXR0cnMpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zLCBlbCA9ICh0YWdOYW1lID09IG51bGwpID8gJ3NwYW4nIDogdGFnTmFtZSwgZWxBdHRyID0gJycsIHdyYXBwZWQgPSAnJztcbiAgICAgIGlmKHR5cGVvZiB0YWdBdHRycyA9PSAnb2JqZWN0JykgZm9yKHZhciBwcm9wIGluIHRhZ0F0dHJzKSBlbEF0dHIgKz0gJyAnICsgcHJvcCArICc9XCInICsobmV3IHRoaXMuY29uc3RydWN0b3IodGFnQXR0cnNbcHJvcF0pKS5lc2NhcGVIVE1MKCkgKyAnXCInO1xuICAgICAgcyA9IHdyYXBwZWQuY29uY2F0KCc8JywgZWwsIGVsQXR0ciwgJz4nLCB0aGlzLCAnPC8nLCBlbCwgJz4nKTtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbWV0aG9kc0FkZGVkID0gW107XG4gIGZ1bmN0aW9uIGV4dGVuZFByb3RvdHlwZSgpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIF9fc3ApIHtcbiAgICAgIChmdW5jdGlvbihuYW1lKXtcbiAgICAgICAgdmFyIGZ1bmMgPSBfX3NwW25hbWVdO1xuICAgICAgICBpZiAoIV9fbnNwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgbWV0aG9kc0FkZGVkLnB1c2gobmFtZSk7XG4gICAgICAgICAgX19uc3BbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUucyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVByb3RvdHlwZSgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHNBZGRlZC5sZW5ndGg7ICsraSlcbiAgICAgIGRlbGV0ZSBTdHJpbmcucHJvdG90eXBlW21ldGhvZHNBZGRlZFtpXV07XG4gICAgbWV0aG9kc0FkZGVkLmxlbmd0aCA9IDA7XG4gIH1cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyogQXR0YWNoIE5hdGl2ZSBKYXZhU2NyaXB0IFN0cmluZyBQcm9wZXJ0aWVzXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICB2YXIgbmF0aXZlUHJvcGVydGllcyA9IGdldE5hdGl2ZVN0cmluZ1Byb3BlcnRpZXMoKTtcbiAgZm9yICh2YXIgbmFtZSBpbiBuYXRpdmVQcm9wZXJ0aWVzKSB7XG4gICAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBzdHJpbmdQcm9wID0gX19uc3BbbmFtZV07XG4gICAgICBpZiAodHlwZW9mIHN0cmluZ1Byb3AgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvL2NvbnNvbGUubG9nKHN0cmluZ1Byb3ApXG4gICAgICAgIGlmICghX19zcFtuYW1lXSkge1xuICAgICAgICAgIGlmIChuYXRpdmVQcm9wZXJ0aWVzW25hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgX19zcFtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKG5hbWUpXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzdHJpbmdQcm9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfX3NwW25hbWVdID0gc3RyaW5nUHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KShuYW1lKTtcbiAgfVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKiBGdW5jdGlvbiBBbGlhc2VzXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICBfX3NwLnJlcGVhdCA9IF9fc3AudGltZXM7XG4gIF9fc3AuaW5jbHVkZSA9IF9fc3AuY29udGFpbnM7XG4gIF9fc3AudG9JbnRlZ2VyID0gX19zcC50b0ludDtcbiAgX19zcC50b0Jvb2wgPSBfX3NwLnRvQm9vbGVhbjtcbiAgX19zcC5kZWNvZGVIVE1MRW50aXRpZXMgPSBfX3NwLmRlY29kZUh0bWxFbnRpdGllcyAvL2Vuc3VyZSBjb25zaXN0ZW50IGNhc2luZyBzY2hlbWUgb2YgJ0hUTUwnXG5cblxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIFNldCB0aGUgY29uc3RydWN0b3IuICBXaXRob3V0IHRoaXMsIHN0cmluZy5qcyBvYmplY3RzIGFyZSBpbnN0YW5jZXMgb2Zcbi8vIE9iamVjdCBpbnN0ZWFkIG9mIFMuXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIF9fc3AuY29uc3RydWN0b3IgPSBTO1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKiBQcml2YXRlIEZ1bmN0aW9uc1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgZnVuY3Rpb24gZ2V0TmF0aXZlU3RyaW5nUHJvcGVydGllcygpIHtcbiAgICB2YXIgbmFtZXMgPSBnZXROYXRpdmVTdHJpbmdQcm9wZXJ0eU5hbWVzKCk7XG4gICAgdmFyIHJldE9iaiA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHZhciBmdW5jID0gX19uc3BbbmFtZV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyAjMTI3OiBwYXNzIGV4dHJhIHBhcmFtZXRlciB0byBrZWVwIHNoZWxsanMgaGFwcHlcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYy5hcHBseSgndGVzdCcsIFsnc3RyaW5nJ10pO1xuICAgICAgICByZXRPYmpbbmFtZV0gPSB0eXBlO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgcmV0dXJuIHJldE9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5hdGl2ZVN0cmluZ1Byb3BlcnR5TmFtZXMoKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgIHJlc3VsdHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhfX25zcCk7XG4gICAgICByZXN1bHRzLnNwbGljZShyZXN1bHRzLmluZGV4T2YoJ3ZhbHVlT2YnKSwgMSk7XG4gICAgICByZXN1bHRzLnNwbGljZShyZXN1bHRzLmluZGV4T2YoJ3RvU3RyaW5nJyksIDEpO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBlbHNlIHsgLy9tZWFudCBmb3IgbGVnYWN5IGNydWZ0LCB0aGlzIGNvdWxkIHByb2JhYmx5IGJlIG1hZGUgbW9yZSBlZmZpY2llbnRcbiAgICAgIHZhciBzdHJpbmdOYW1lcyA9IHt9O1xuICAgICAgdmFyIG9iamVjdE5hbWVzID0gW107XG4gICAgICBmb3IgKHZhciBuYW1lIGluIFN0cmluZy5wcm90b3R5cGUpXG4gICAgICAgIHN0cmluZ05hbWVzW25hbWVdID0gbmFtZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBPYmplY3QucHJvdG90eXBlKVxuICAgICAgICBkZWxldGUgc3RyaW5nTmFtZXNbbmFtZV07XG5cbiAgICAgIC8vc3RyaW5nTmFtZXNbJ3RvU3RyaW5nJ10gPSAndG9TdHJpbmcnOyAvL3RoaXMgd2FzIGRlbGV0ZWQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgb2JqZWN0IG5hbWVzXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHN0cmluZ05hbWVzKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEV4cG9ydChzdHIpIHtcbiAgICByZXR1cm4gbmV3IFMoc3RyKTtcbiAgfTtcblxuICAvL2F0dGFjaCBleHBvcnRzIHRvIFN0cmluZ0pTV3JhcHBlclxuICBFeHBvcnQuZXh0ZW5kUHJvdG90eXBlID0gZXh0ZW5kUHJvdG90eXBlO1xuICBFeHBvcnQucmVzdG9yZVByb3RvdHlwZSA9IHJlc3RvcmVQcm90b3R5cGU7XG4gIEV4cG9ydC5WRVJTSU9OID0gVkVSU0lPTjtcbiAgRXhwb3J0LlRNUExfT1BFTiA9ICd7eyc7XG4gIEV4cG9ydC5UTVBMX0NMT1NFID0gJ319JztcbiAgRXhwb3J0LkVOVElUSUVTID0gRU5USVRJRVM7XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyogRXhwb3J0c1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFeHBvcnQ7XG5cbiAgfSBlbHNlIHtcblxuICAgIGlmKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRXhwb3J0O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5TID0gRXhwb3J0O1xuICAgIH1cbiAgfVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKiAzcmQgUGFydHkgUHJpdmF0ZSBGdW5jdGlvbnNcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8vZnJvbSBzdWdhci5qc1xuICBmdW5jdGlvbiBtdWx0aUFyZ3MoYXJncywgZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYXJnc1tpXSk7XG4gICAgICBpZihmbikgZm4uY2FsbChhcmdzLCBhcmdzW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vZnJvbSB1bmRlcnNjb3JlLnN0cmluZ1xuICB2YXIgZXNjYXBlQ2hhcnMgPSB7XG4gICAgbHQ6ICc8JyxcbiAgICBndDogJz4nLFxuICAgIHF1b3Q6ICdcIicsXG4gICAgYXBvczogXCInXCIsXG4gICAgYW1wOiAnJidcbiAgfTtcblxuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAgKHMpIHtcbiAgICAvLyBtb3N0IHBhcnQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2t1bHB0L3NrdWxwdC9ibG9iL2VjYWY3NWU2OWMyZTUzOWVmZjEyNGIyYWI0NWRmMGIwMWVhZjIyOTUvc3JjL3N0ci5qcyNMMjQyXG4gICAgdmFyIGM7XG4gICAgdmFyIGk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciByZSA9IC9eW0EtWmEtejAtOV0rJC87XG4gICAgcyA9IGVuc3VyZVN0cmluZyhzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgYyA9IHMuY2hhckF0KGkpO1xuXG4gICAgICBpZiAocmUudGVzdChjKSkge1xuICAgICAgICByZXQucHVzaChjKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoYyA9PT0gXCJcXFxcMDAwXCIpIHtcbiAgICAgICAgICByZXQucHVzaChcIlxcXFwwMDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goXCJcXFxcXCIgKyBjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdHJpbmcoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgfVxuXG4gIC8vZnJvbSB1bmRlcnNjb3JlLnN0cmluZ1xuICB2YXIgcmV2ZXJzZWRFc2NhcGVDaGFycyA9IHt9O1xuICBmb3IodmFyIGtleSBpbiBlc2NhcGVDaGFycyl7IHJldmVyc2VkRXNjYXBlQ2hhcnNbZXNjYXBlQ2hhcnNba2V5XV0gPSBrZXk7IH1cblxuICBFTlRJVElFUyA9IHtcbiAgICBcImFtcFwiIDogXCImXCIsXG4gICAgXCJndFwiIDogXCI+XCIsXG4gICAgXCJsdFwiIDogXCI8XCIsXG4gICAgXCJxdW90XCIgOiBcIlxcXCJcIixcbiAgICBcImFwb3NcIiA6IFwiJ1wiLFxuICAgIFwiQUVsaWdcIiA6IDE5OCxcbiAgICBcIkFhY3V0ZVwiIDogMTkzLFxuICAgIFwiQWNpcmNcIiA6IDE5NCxcbiAgICBcIkFncmF2ZVwiIDogMTkyLFxuICAgIFwiQXJpbmdcIiA6IDE5NyxcbiAgICBcIkF0aWxkZVwiIDogMTk1LFxuICAgIFwiQXVtbFwiIDogMTk2LFxuICAgIFwiQ2NlZGlsXCIgOiAxOTksXG4gICAgXCJFVEhcIiA6IDIwOCxcbiAgICBcIkVhY3V0ZVwiIDogMjAxLFxuICAgIFwiRWNpcmNcIiA6IDIwMixcbiAgICBcIkVncmF2ZVwiIDogMjAwLFxuICAgIFwiRXVtbFwiIDogMjAzLFxuICAgIFwiSWFjdXRlXCIgOiAyMDUsXG4gICAgXCJJY2lyY1wiIDogMjA2LFxuICAgIFwiSWdyYXZlXCIgOiAyMDQsXG4gICAgXCJJdW1sXCIgOiAyMDcsXG4gICAgXCJOdGlsZGVcIiA6IDIwOSxcbiAgICBcIk9hY3V0ZVwiIDogMjExLFxuICAgIFwiT2NpcmNcIiA6IDIxMixcbiAgICBcIk9ncmF2ZVwiIDogMjEwLFxuICAgIFwiT3NsYXNoXCIgOiAyMTYsXG4gICAgXCJPdGlsZGVcIiA6IDIxMyxcbiAgICBcIk91bWxcIiA6IDIxNCxcbiAgICBcIlRIT1JOXCIgOiAyMjIsXG4gICAgXCJVYWN1dGVcIiA6IDIxOCxcbiAgICBcIlVjaXJjXCIgOiAyMTksXG4gICAgXCJVZ3JhdmVcIiA6IDIxNyxcbiAgICBcIlV1bWxcIiA6IDIyMCxcbiAgICBcIllhY3V0ZVwiIDogMjIxLFxuICAgIFwiYWFjdXRlXCIgOiAyMjUsXG4gICAgXCJhY2lyY1wiIDogMjI2LFxuICAgIFwiYWVsaWdcIiA6IDIzMCxcbiAgICBcImFncmF2ZVwiIDogMjI0LFxuICAgIFwiYXJpbmdcIiA6IDIyOSxcbiAgICBcImF0aWxkZVwiIDogMjI3LFxuICAgIFwiYXVtbFwiIDogMjI4LFxuICAgIFwiY2NlZGlsXCIgOiAyMzEsXG4gICAgXCJlYWN1dGVcIiA6IDIzMyxcbiAgICBcImVjaXJjXCIgOiAyMzQsXG4gICAgXCJlZ3JhdmVcIiA6IDIzMixcbiAgICBcImV0aFwiIDogMjQwLFxuICAgIFwiZXVtbFwiIDogMjM1LFxuICAgIFwiaWFjdXRlXCIgOiAyMzcsXG4gICAgXCJpY2lyY1wiIDogMjM4LFxuICAgIFwiaWdyYXZlXCIgOiAyMzYsXG4gICAgXCJpdW1sXCIgOiAyMzksXG4gICAgXCJudGlsZGVcIiA6IDI0MSxcbiAgICBcIm9hY3V0ZVwiIDogMjQzLFxuICAgIFwib2NpcmNcIiA6IDI0NCxcbiAgICBcIm9ncmF2ZVwiIDogMjQyLFxuICAgIFwib3NsYXNoXCIgOiAyNDgsXG4gICAgXCJvdGlsZGVcIiA6IDI0NSxcbiAgICBcIm91bWxcIiA6IDI0NixcbiAgICBcInN6bGlnXCIgOiAyMjMsXG4gICAgXCJ0aG9yblwiIDogMjU0LFxuICAgIFwidWFjdXRlXCIgOiAyNTAsXG4gICAgXCJ1Y2lyY1wiIDogMjUxLFxuICAgIFwidWdyYXZlXCIgOiAyNDksXG4gICAgXCJ1dW1sXCIgOiAyNTIsXG4gICAgXCJ5YWN1dGVcIiA6IDI1MyxcbiAgICBcInl1bWxcIiA6IDI1NSxcbiAgICBcImNvcHlcIiA6IDE2OSxcbiAgICBcInJlZ1wiIDogMTc0LFxuICAgIFwibmJzcFwiIDogMTYwLFxuICAgIFwiaWV4Y2xcIiA6IDE2MSxcbiAgICBcImNlbnRcIiA6IDE2MixcbiAgICBcInBvdW5kXCIgOiAxNjMsXG4gICAgXCJjdXJyZW5cIiA6IDE2NCxcbiAgICBcInllblwiIDogMTY1LFxuICAgIFwiYnJ2YmFyXCIgOiAxNjYsXG4gICAgXCJzZWN0XCIgOiAxNjcsXG4gICAgXCJ1bWxcIiA6IDE2OCxcbiAgICBcIm9yZGZcIiA6IDE3MCxcbiAgICBcImxhcXVvXCIgOiAxNzEsXG4gICAgXCJub3RcIiA6IDE3MixcbiAgICBcInNoeVwiIDogMTczLFxuICAgIFwibWFjclwiIDogMTc1LFxuICAgIFwiZGVnXCIgOiAxNzYsXG4gICAgXCJwbHVzbW5cIiA6IDE3NyxcbiAgICBcInN1cDFcIiA6IDE4NSxcbiAgICBcInN1cDJcIiA6IDE3OCxcbiAgICBcInN1cDNcIiA6IDE3OSxcbiAgICBcImFjdXRlXCIgOiAxODAsXG4gICAgXCJtaWNyb1wiIDogMTgxLFxuICAgIFwicGFyYVwiIDogMTgyLFxuICAgIFwibWlkZG90XCIgOiAxODMsXG4gICAgXCJjZWRpbFwiIDogMTg0LFxuICAgIFwib3JkbVwiIDogMTg2LFxuICAgIFwicmFxdW9cIiA6IDE4NyxcbiAgICBcImZyYWMxNFwiIDogMTg4LFxuICAgIFwiZnJhYzEyXCIgOiAxODksXG4gICAgXCJmcmFjMzRcIiA6IDE5MCxcbiAgICBcImlxdWVzdFwiIDogMTkxLFxuICAgIFwidGltZXNcIiA6IDIxNSxcbiAgICBcImRpdmlkZVwiIDogMjQ3LFxuICAgIFwiT0VsaWc7XCIgOiAzMzgsXG4gICAgXCJvZWxpZztcIiA6IDMzOSxcbiAgICBcIlNjYXJvbjtcIiA6IDM1MixcbiAgICBcInNjYXJvbjtcIiA6IDM1MyxcbiAgICBcIll1bWw7XCIgOiAzNzYsXG4gICAgXCJmbm9mO1wiIDogNDAyLFxuICAgIFwiY2lyYztcIiA6IDcxMCxcbiAgICBcInRpbGRlO1wiIDogNzMyLFxuICAgIFwiQWxwaGE7XCIgOiA5MTMsXG4gICAgXCJCZXRhO1wiIDogOTE0LFxuICAgIFwiR2FtbWE7XCIgOiA5MTUsXG4gICAgXCJEZWx0YTtcIiA6IDkxNixcbiAgICBcIkVwc2lsb247XCIgOiA5MTcsXG4gICAgXCJaZXRhO1wiIDogOTE4LFxuICAgIFwiRXRhO1wiIDogOTE5LFxuICAgIFwiVGhldGE7XCIgOiA5MjAsXG4gICAgXCJJb3RhO1wiIDogOTIxLFxuICAgIFwiS2FwcGE7XCIgOiA5MjIsXG4gICAgXCJMYW1iZGE7XCIgOiA5MjMsXG4gICAgXCJNdTtcIiA6IDkyNCxcbiAgICBcIk51O1wiIDogOTI1LFxuICAgIFwiWGk7XCIgOiA5MjYsXG4gICAgXCJPbWljcm9uO1wiIDogOTI3LFxuICAgIFwiUGk7XCIgOiA5MjgsXG4gICAgXCJSaG87XCIgOiA5MjksXG4gICAgXCJTaWdtYTtcIiA6IDkzMSxcbiAgICBcIlRhdTtcIiA6IDkzMixcbiAgICBcIlVwc2lsb247XCIgOiA5MzMsXG4gICAgXCJQaGk7XCIgOiA5MzQsXG4gICAgXCJDaGk7XCIgOiA5MzUsXG4gICAgXCJQc2k7XCIgOiA5MzYsXG4gICAgXCJPbWVnYTtcIiA6IDkzNyxcbiAgICBcImFscGhhO1wiIDogOTQ1LFxuICAgIFwiYmV0YTtcIiA6IDk0NixcbiAgICBcImdhbW1hO1wiIDogOTQ3LFxuICAgIFwiZGVsdGE7XCIgOiA5NDgsXG4gICAgXCJlcHNpbG9uO1wiIDogOTQ5LFxuICAgIFwiemV0YTtcIiA6IDk1MCxcbiAgICBcImV0YTtcIiA6IDk1MSxcbiAgICBcInRoZXRhO1wiIDogOTUyLFxuICAgIFwiaW90YTtcIiA6IDk1MyxcbiAgICBcImthcHBhO1wiIDogOTU0LFxuICAgIFwibGFtYmRhO1wiIDogOTU1LFxuICAgIFwibXU7XCIgOiA5NTYsXG4gICAgXCJudTtcIiA6IDk1NyxcbiAgICBcInhpO1wiIDogOTU4LFxuICAgIFwib21pY3JvbjtcIiA6IDk1OSxcbiAgICBcInBpO1wiIDogOTYwLFxuICAgIFwicmhvO1wiIDogOTYxLFxuICAgIFwic2lnbWFmO1wiIDogOTYyLFxuICAgIFwic2lnbWE7XCIgOiA5NjMsXG4gICAgXCJ0YXU7XCIgOiA5NjQsXG4gICAgXCJ1cHNpbG9uO1wiIDogOTY1LFxuICAgIFwicGhpO1wiIDogOTY2LFxuICAgIFwiY2hpO1wiIDogOTY3LFxuICAgIFwicHNpO1wiIDogOTY4LFxuICAgIFwib21lZ2E7XCIgOiA5NjksXG4gICAgXCJ0aGV0YXN5bTtcIiA6IDk3NyxcbiAgICBcInVwc2loO1wiIDogOTc4LFxuICAgIFwicGl2O1wiIDogOTgyLFxuICAgIFwiZW5zcDtcIiA6IDgxOTQsXG4gICAgXCJlbXNwO1wiIDogODE5NSxcbiAgICBcInRoaW5zcDtcIiA6IDgyMDEsXG4gICAgXCJ6d25qO1wiIDogODIwNCxcbiAgICBcInp3ajtcIiA6IDgyMDUsXG4gICAgXCJscm07XCIgOiA4MjA2LFxuICAgIFwicmxtO1wiIDogODIwNyxcbiAgICBcIm5kYXNoO1wiIDogODIxMSxcbiAgICBcIm1kYXNoO1wiIDogODIxMixcbiAgICBcImxzcXVvO1wiIDogODIxNixcbiAgICBcInJzcXVvO1wiIDogODIxNyxcbiAgICBcInNicXVvO1wiIDogODIxOCxcbiAgICBcImxkcXVvO1wiIDogODIyMCxcbiAgICBcInJkcXVvO1wiIDogODIyMSxcbiAgICBcImJkcXVvO1wiIDogODIyMixcbiAgICBcImRhZ2dlcjtcIiA6IDgyMjQsXG4gICAgXCJEYWdnZXI7XCIgOiA4MjI1LFxuICAgIFwiYnVsbDtcIiA6IDgyMjYsXG4gICAgXCJoZWxsaXA7XCIgOiA4MjMwLFxuICAgIFwicGVybWlsO1wiIDogODI0MCxcbiAgICBcInByaW1lO1wiIDogODI0MixcbiAgICBcIlByaW1lO1wiIDogODI0MyxcbiAgICBcImxzYXF1bztcIiA6IDgyNDksXG4gICAgXCJyc2FxdW87XCIgOiA4MjUwLFxuICAgIFwib2xpbmU7XCIgOiA4MjU0LFxuICAgIFwiZnJhc2w7XCIgOiA4MjYwLFxuICAgIFwiZXVybztcIiA6IDgzNjQsXG4gICAgXCJpbWFnZTtcIiA6IDg0NjUsXG4gICAgXCJ3ZWllcnA7XCIgOiA4NDcyLFxuICAgIFwicmVhbDtcIiA6IDg0NzYsXG4gICAgXCJ0cmFkZTtcIiA6IDg0ODIsXG4gICAgXCJhbGVmc3ltO1wiIDogODUwMSxcbiAgICBcImxhcnI7XCIgOiA4NTkyLFxuICAgIFwidWFycjtcIiA6IDg1OTMsXG4gICAgXCJyYXJyO1wiIDogODU5NCxcbiAgICBcImRhcnI7XCIgOiA4NTk1LFxuICAgIFwiaGFycjtcIiA6IDg1OTYsXG4gICAgXCJjcmFycjtcIiA6IDg2MjksXG4gICAgXCJsQXJyO1wiIDogODY1NixcbiAgICBcInVBcnI7XCIgOiA4NjU3LFxuICAgIFwickFycjtcIiA6IDg2NTgsXG4gICAgXCJkQXJyO1wiIDogODY1OSxcbiAgICBcImhBcnI7XCIgOiA4NjYwLFxuICAgIFwiZm9yYWxsO1wiIDogODcwNCxcbiAgICBcInBhcnQ7XCIgOiA4NzA2LFxuICAgIFwiZXhpc3Q7XCIgOiA4NzA3LFxuICAgIFwiZW1wdHk7XCIgOiA4NzA5LFxuICAgIFwibmFibGE7XCIgOiA4NzExLFxuICAgIFwiaXNpbjtcIiA6IDg3MTIsXG4gICAgXCJub3RpbjtcIiA6IDg3MTMsXG4gICAgXCJuaTtcIiA6IDg3MTUsXG4gICAgXCJwcm9kO1wiIDogODcxOSxcbiAgICBcInN1bTtcIiA6IDg3MjEsXG4gICAgXCJtaW51cztcIiA6IDg3MjIsXG4gICAgXCJsb3dhc3Q7XCIgOiA4NzI3LFxuICAgIFwicmFkaWM7XCIgOiA4NzMwLFxuICAgIFwicHJvcDtcIiA6IDg3MzMsXG4gICAgXCJpbmZpbjtcIiA6IDg3MzQsXG4gICAgXCJhbmc7XCIgOiA4NzM2LFxuICAgIFwiYW5kO1wiIDogODc0MyxcbiAgICBcIm9yO1wiIDogODc0NCxcbiAgICBcImNhcDtcIiA6IDg3NDUsXG4gICAgXCJjdXA7XCIgOiA4NzQ2LFxuICAgIFwiaW50O1wiIDogODc0NyxcbiAgICBcInRoZXJlNDtcIiA6IDg3NTYsXG4gICAgXCJzaW07XCIgOiA4NzY0LFxuICAgIFwiY29uZztcIiA6IDg3NzMsXG4gICAgXCJhc3ltcDtcIiA6IDg3NzYsXG4gICAgXCJuZTtcIiA6IDg4MDAsXG4gICAgXCJlcXVpdjtcIiA6IDg4MDEsXG4gICAgXCJsZTtcIiA6IDg4MDQsXG4gICAgXCJnZTtcIiA6IDg4MDUsXG4gICAgXCJzdWI7XCIgOiA4ODM0LFxuICAgIFwic3VwO1wiIDogODgzNSxcbiAgICBcIm5zdWI7XCIgOiA4ODM2LFxuICAgIFwic3ViZTtcIiA6IDg4MzgsXG4gICAgXCJzdXBlO1wiIDogODgzOSxcbiAgICBcIm9wbHVzO1wiIDogODg1MyxcbiAgICBcIm90aW1lcztcIiA6IDg4NTUsXG4gICAgXCJwZXJwO1wiIDogODg2OSxcbiAgICBcInNkb3Q7XCIgOiA4OTAxLFxuICAgIFwibGNlaWw7XCIgOiA4OTY4LFxuICAgIFwicmNlaWw7XCIgOiA4OTY5LFxuICAgIFwibGZsb29yO1wiIDogODk3MCxcbiAgICBcInJmbG9vcjtcIiA6IDg5NzEsXG4gICAgXCJsYW5nO1wiIDogOTAwMSxcbiAgICBcInJhbmc7XCIgOiA5MDAyLFxuICAgIFwibG96O1wiIDogOTY3NCxcbiAgICBcInNwYWRlcztcIiA6IDk4MjQsXG4gICAgXCJjbHVicztcIiA6IDk4MjcsXG4gICAgXCJoZWFydHM7XCIgOiA5ODI5LFxuICAgIFwiZGlhbXM7XCIgOiA5ODMwXG4gIH1cblxuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjNcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMyc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgcHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gcHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iXX0=
